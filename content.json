[{"title":"RACCommand粗解","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/RACCommand/","text":"迷之RACCommandRACCommand 最常用于两个地方，监听按钮点击，网络请求说实在就是一个执行方法的Block 1 按钮点击，使用 RAC 有两种方式 UIControl+RACSignalSupport 123//返回一个Signal- (RACSignal *)rac_signalForControlEvents:(UIControlEvents)controlEvents; UIButton+RACCommandSupport 123//定义一个属性(类似Block)@property(nonatomic, strong) RACCommand *rac_command; 2. 使用SignalForControlEvents来触发(方法只要点击就触发,等于addTarget) 1234567891011121314151617181920212223242526272829 // 按钮是否可点击RAC(self.commandBtn, enabled) = validSignal;[[[self.commandBtn rac_signalForControlEvents:UIControlEventTouchUpInside] // flattenMap 生成新的信号，在信号中可以处理点击事件，并发送结果 //flattenMap map 用于把源信号内容映射成新的内容。 flattenMap:^RACStream *(id value) &#123; return [self btnClickSignal]; &#125;] subscribeNext:^(id x) &#123; NSLog(@\"====%@\", x); // ====按钮点击了 &#125;]; - (RACSignal *)btnClickSignal &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; /** * 这里可以进行处理按钮点击后的事件，并把想要的结果传递出去 */ [subscriber sendNext:@\"按钮点击了\"]; [subscriber sendCompleted]; return nil; &#125;];&#125; 上述就是根据 UIControl 的分类信息，进行处理按钮点击事件的第一种方式。但是有一个问题 只有手动点击了按钮，并且是 UIControlEventTouchUpInside 的事件状态下才会执行 block 中的代码。 如果需要主动触发事件呢，而在老代码中，可以手动调用 [self btnClick] ，所以就必须使用第二种方式， RACCommand 3. RACCommand 初始化 rac_command 123456789// 初始化 command， enabled 表示按钮可否点击RACCommand *command = [[RACCommand alloc] initWithEnabled:validSignal signalBlock:^RACSignal *(id input) &#123; return [self btnClickSignal]; &#125;];self.commandBtn.rac_command = command;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"https://swlfigo.github.io/tags/ReactiveCocoa/"}]},{"title":"正则表达学习","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/RegularExpressionLearn/","text":"正则表达学习在线正则表达式测试地址 &lt;- 点我Sample1: 找出以 lefe 或 lefe_x 单词开头，以 wsy 结尾的字符串。比如：lefe name is wsy 是合法的，而 lef name is wsy 是非法的。 正则表达式为：(^(?:lefe|lefe_x)\\b.{0,}wsy$) 1.^表示从字符串的开始位置匹配，^(?:lefe|lefe_x) 表示以 lefe 或者 lefe_x 开头； | 表示或，比如 A | B | C ，表示 A，B 和 C 中任意一个； () 表示一个组，(?:) 表示不捕获这个分组； \\b 表示匹配一个单词的边界，在这里只能匹配 lefe 和 lefe_x;5.匹配字符串的开头和结尾后，基本上完成了题目的要求，但是字符串lefe（lefe_x）和wsy之间可以是任意字符，. 表示匹配任意字符（不包含换行符），{0,}表示匹配0个或多个字符，则.{0,} 表示匹配0个或多个任意字符（不包含换行符）；6.$表示从字符串的结尾处开始匹配，wsy$ 则表示以 wsy 结尾； 【 知识点 】 字符边界^，$ 和 \\b 表示字符的边界，^ 匹配字符串的开头，$匹配字符串的结尾，\\b匹配单词的边界，如：lefe\\b 可以匹配 lefe ，但不可匹配 lefe_x； 量词{m} 只出现 m 次，lefe{2} 只能匹配 lefee{m,n} 出现 m 到 n 次{m,} 至少出现 m 次 选择表达式比如 lefe | Lefe_x | Lefe ，表示 lefe，Lefe_x 和 Lefe 中任意一个 分组以括号括起来的字符集为一个分组，在 ( 添加 ?: 将忽略这个分组 ) 字符集. 匹配除换行符以外的任意一个字符\\w = [0-9a-zA-Z_]\\W = [^0-9a-zA-Z_]\\s = [\\t\\n\\v]\\S = [^\\t\\n\\v]\\d = [0-9]\\D = [^0-9] 正则表达式分组()、不捕获(?:)分组分组在正则中用()表示，分组的作用有两个： 1.将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。 2.分组之后，可以通过后向引用简化表达式（\\1 或者$1）。 分组举列先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式： \\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3} 但仔细观察，可以发现一定的规律，可以把.\\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下： \\d{1,3}(.\\d{1,3}){3} 再来看第二个作用，就拿匹配xxx标签来说，简单的正则可以这样写： &lt;title&gt;.*&lt;/title&gt; 可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下： &lt;(title)&gt;.*&lt;/\\1&gt; 对于分组而言，整个表达式永远算作第0组，在本例中，第0组是&lt;(title)&gt;.*&lt;/\\1&gt;，然后从左到右，依次为分组编号，因此，(title)是第1组。 [(xxx) 一个括号等于一个分组] 注意： 用\\1这种语法，可以引用某组的文本内容，但不能引用正则表达式。 例如刚刚的IP地址正则表达式为\\d{1,3}(.\\d{1,3}){3}，里边的\\d{1,3}重复了两次，如果利用后向引用简化，表达式如下： 错误示范:(\\d{1,3})(.\\1){3} 后向引用，引用的仅仅是文本内容，而不是正则表达式！ 也就是说，组中的内容一旦匹配成功，后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。 因此，(\\d{1,3})(.\\1){3}这个表达式实际上匹配的是四个数都相同的IP地址，比如：123.123.123.123。 不捕获不捕获就是在分组的前边加上?: ，可以在不需要捕获分组的表达式中使用，加快表达式执行速度。 就拿匹配xxx标签来说，通过分组可以简写为 &lt;(title)&gt;.*&lt;/\\1&gt; 但是如果是 (?:title) ,则\\1就不能捕获到这个子组了，只能捕获第一个出现的非 ?: 的分组作为\\1 同时注意(?:title)本身会在完整匹配中，只是不在子组中，注意和断言的区别 12345678910$str=\"ab123ff\";//正常,完整匹配为ab123ff, 有两个子组ab, ffpreg_match_all(\"|([a-z]&#123;2&#125;).*([a-z]&#123;2&#125;)|U\", $str, $out);echo \"&lt;pre&gt;\";print_r($out);echo \"&lt;/pre&gt;\";//不捕获分组,完整匹配为ab23ff, 有一个子组ffpreg_match_all(\"|(?:[a-z]&#123;2&#125;).*([a-z]&#123;2&#125;)|U\", $str, $out);echo \"&lt;pre&gt;\";print_r($out);echo \"&lt;/pre&gt;\"; Sample2 :匹配以 lefe 开头，lefe 后面不能紧跟_x，后面由数字，-，_和字母组成，且不包含l,e,f 三个字母中的任意一个(至少一位)，且为最短的用户名 【分析】根据要求可以把题目拆分成：1.以 lefe 开头，不能为 lefe_x。可以转换成 ^lefe(?!_x);2.中间部分由数字，-，和字母组成，不能包含 l,e,f，至少一位。可以转换成 `[0-9a-dg-km-zA-DG-KM-Z-]+; 3.匹配最短的。在正则表达式中用到了贪婪与非贪婪的概念，使用?`; 【正则表达式】 ^(lefe(?!_x)(?:[0-9a-dg-km-zA-DG-KM-Z_-]+?) 知识点1.非获取匹配lefe(?=_x) ，lefe 后面紧跟着 _x，正向肯定预查lefe(?!_x) ，lefe 后面不能出现 _x，正向否的定预查(?&lt;!lefe)_x ，_x 前面不能为 lefe，反向肯定预查(?&lt;=lefe)_x ，_x 前面为 lefe，反向否的定预查2.字符集合[xyz] 匹配 x,y,z 任意一个字符；[^xyz] 匹配除 x,y,z 外的任意一个字符；[a-z] 匹配 a-z 中任意一个字符；3.贪婪匹配与非贪婪匹配默认的匹配规则为非贪婪匹配，使用 ? 使贪婪匹配变为非贪婪匹配。比如：使用正则表达式lefe{2,} 匹配 lefeeeeeeee，如果为贪婪匹配(lefe{2,})时将匹配 lefeeeeeeee，为非贪婪匹配(lefe{2,}?)时，将匹配 lefee。4.量词 *，+，?&#39;lefe*&#39; ，lef 后有0个或多个e&#39;lefe+&#39; ，lef 后有1个或多个e&#39;lefe?&#39; ，lef 后有0个或1个e","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"ScrollView、TableView、CollectionView 联动一种实现思路","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/ScrollViewNestTableViewAndCollectionView/","text":"ScrollView、TableView、CollectionView 联动一种实现思路首先看看效果: 带悬停View头部的类型,可以上下拉刷新 2.不带悬停View头部的类型,可以上下拉刷新 (PS.图床上传GIF有问题，经常出现卡死问题,直接运行DEMO比较直观) → Demo地址 联动思路实现核心思路大部分处理方案由于联动是在最底部的 ScrollView 上面添加一个 TableVIew 或者 CollectionView 之类的, 最大难点就是 手势处理 . 嵌套 ScrollView之后,需要一个条件来控制某个具体时刻那个 ScrollView 响应滑动事件。 通常，我们会在 ScrollView 代理方法里面 12345- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;//blablabla 逻辑&#125; 例如，我们会实现这样一个逻辑，最底部有一个 mainScrollView ， mainScrollView 上有一个 SubScrollView, 这样就类似一个双 ScrollView嵌套场景了 1234567891011//写个伪代码if (scrollView.contentOffset.y &gt; maxOffsetY)&#123; mainScrollView.isScrollEnabled = false; subScrollView.isScrollEnabled = true;&#125;else&#123; // 当 subScrollView 滑动到顶部时，停止响应，mainScrollView 开始响应 if scrollView.contentOffset.y &lt; 0&#123; subScrollView.isScrollEnabled = false; mainScrollView.isScrollEnabled = ture; &#125;&#125; 代理方法里面 scrollViewDidScroll 中进行判断，当 mainScrollView 划出了 maxOffsetY ，停止响应滚动，继续滑动时候，就是 subScrollView 响应滚动了 但是，在实际操作上有个很大问题，使用者并不是总能滑动到 maxOffsetY 地方，停下手，进行下一次滑动，如果滑动大于 maxOffsetY 地方， mainScrollView 就会滚动到 maxOffsetY 之后，停止响应，是因为这是一次手势， subScrollView 也不会响应，使用者就有中断感觉，需要第二次滑动才能继续滚动 改变一下思路由于有上面的不足，我们就改变一下思路.大家都知道，每个 ScrollView 都带有一个 panGestureRecognizer 的手势,如果可以控制这个手势，就理论上能优化了,那么我们就有: 1mainScrollView.panGestureRecognizer.delegate = self; 结果App 运行后报错: ‘UIScrollView’s built-in pan gesture recognizer must have its scroll view as its delegate’ 解决的思路是我们自己添加一个联动的 pan 手势UIGestureRecognizerDelegate里面有一个委托方法： 123- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer &#123; return YES;&#125; 只需要将其返回YES即可同时执行多种手势；如果手势之间或手势对应的视图有冲突或者有不同的需求，可以在这个方法里面添加一些相应的判断，例如一个uiview里面有3个手势分别是移动、缩放、旋转，而我只需要同时执行缩放和旋转的话： 123456789101112// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)//// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture's delegate may return YES- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; if ([gestureRecognizer isKindOfClass:[UIPinchGestureRecognizer class]] &amp;&amp; [otherGestureRecognizer isKindOfClass:[UIRotationGestureRecognizer class]]) &#123; return YES; &#125;returnNO;&#125; 一句话总结就是此方法返回YES时，手势事件会一直往下传递，不论当前层次是否对该事件进行响应。 那么，我们可以这样做，在 mainScrollView实现这个代理,让手势传下去，给 subScrollView 回到Demo:此Demo的 ScrollView 样子大概是这样: 如图, 红色框柱区域为 mainScrollView , 蓝色框柱地方为 HeaderView , 紫色框柱的地方是 subScrollView (CollectionView) ; 那么，如果需要悬停（就是红色 headerView 那部分，在 mainScrollView 上滑到最上面时候，卡在最上面， subScrollView 继续滑动）实现思路类似上面所说的，在ScrollView代理中方法里面做文章 12345- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;//blablabla 逻辑&#125; UI布局 首先， subScrollView 是一个 Controller 里面的 CollectionView , mainScrollView 的Controller最底部那个View, 上面添加了一个 headerView(UIView可悬停) , 再添加一个可以左右切换的 segmentScrollView(请联系源码看) , subScrollView就是添加在这个可以左右切换的ScrollView 上,总体来说，mainScrollView 的 ContentSize 就是 HeaderView的高度 + subScrollView里面CollectionView的高度 . 滑动传递 滑动到的时候，因为上面设置了 mainScrollView 的手势方法，可以响应多手势. 在拖着 subScrollView,即 CollectionView 的那个紫色区域时候, 底部的父视图的 mainScrollView也会收到响应，两个 ScrollView 都会进入各自 Controller 的 (void)scrollViewDidScroll:(UIScrollView *)scrollView 方法里面，我们只要在各自方法里面写相应的逻辑判断，则会达到一个联动效果. 滑动逻辑 (具体详情可查看源码，这里说一个大概) mainScrollView : didScroll代理里面 1234567891011//联动滑 CGFloat offsetY = scrollView.contentOffset.y; self.isTopIsCanNotMoveTabViewPre = self.isTopIsCanNotMoveTabView; if (offsetY &gt;= self.scrollMinOffsetY + _headerViewTotalHeight ) &#123; scrollView.contentOffset = CGPointMake(0, _headerViewTotalHeight + self.scrollMinOffsetY); self.isTopIsCanNotMoveTabView = YES; &#125; else &#123; self.isTopIsCanNotMoveTabView = NO; &#125; 先说下这个逻辑, isTopIsCanNotMoveTabViewPre 与 isTopIsCanNotMoveTabView 是一个全局变量，记录了当前状态与前一个状态是否能滑动状态,每次滑动时候，将根据是否达到了极限值而改变布尔类型 1offsetY &gt;= self.scrollMinOffsetY + _headerViewTotalHeight 因为一开始，mainScrollView的offset是在(0,0),向上拖动时候，offsetY增大, 当小于极限值时候 (如果是需要悬停状态，那么极限值就是 头部HeaderView高度 - 需要悬停高度) ， 滚动的是 mainScrollView, subScrollView 的 contentOffset 将会保持 (0,0) , 同理，如果大于极限值， mainScrollView的 contentOffset 也将会保持一个固定值，那么滑动的是 subScrollView , 两者之间将会用通知传递状态信息 注意 Demo中通知名使用的是唯一通知，好处就是，如果多个 Controller 也用到这种结构，在 NavigationController视图堆栈里面还没用清空销毁的 Controller 也会接收到另外 Controller通知，也会触发到 didScroll 方法里面的逻辑，所以，稳妥方法是不同 模块的Controller用唯一通知名 滑动到极限位置 滑动到极限位置时候，HeaderView固定在极限位置, 即 MainScrollView 滑动到极限位置， 然后在 didScroll 代理方法里面,发通知给 SubScrollView ，让 SubScrollView可以滑动 123456789101112if (self.isTopIsCanNotMoveTabView != self.isTopIsCanNotMoveTabViewPre) &#123; if (!self.isTopIsCanNotMoveTabViewPre &amp;&amp; self.isTopIsCanNotMoveTabView) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:_ScrollViewNestControllerViewGoTopNotificationName object:nil userInfo:@&#123;_ScrollViewNestControllerViewCanScrollKey : @\"1\"&#125;]; self.canScroll = NO; &#125; if(self.isTopIsCanNotMoveTabViewPre &amp;&amp; !self.isTopIsCanNotMoveTabView)&#123; if (!self.canScroll) &#123; scrollView.contentOffset = CGPointMake(0, _headerViewTotalHeight + self.scrollMinOffsetY); &#125; &#125; &#125; 逻辑中，根据 canScroll 判断 sub和main是否能滑动 上下拉刷新回调这套实现思路，能做到上下啦刷新，上拉刷新好说，就是在 mainScrollView 上面添加刷新控件，例如 MJReresh , 下拉刷新的话，需要再 subScrollView 上添加，因为，在 mainScrollView 固定不滚动时候，滚动的响应视图是 subScrollView , 所以 , 只能通过回调告诉 mainScrollView做相应操作，当然，如果你项目逻辑只需在 subScrollView里面完成就行的话，就不需要回调，一切视乎项目要求 最后 说下上面实现可能在项目中一些功能上，需求上不足 如果数据量太少，例如数据量不足一屏幕， CollectionView 或者 Tableview 创建时候，是基于一个全屏幕的,所以在滚动到极限位置，开始滚动 subScrollView 时候，下面会有很大一片空白位置, 暂时知道的 微博 也会存在这个问题，如果你们设计没有太大要求就没什么问题。 那么对于这种，解决方法也不是没有，CollectionView 通过 123456[CollectionView performBatchUpdates:^&#123; &#125; completion:^(BOOL finished) &#123;&#125; 这个方法，completion时候，能获得 collectionView 正真的 contentsize高度，那么可以判断是否少于屏幕高度尺寸，再直接设置 mainScrollView 与 subScrollView 的 contentSize 来不给他滚动太大距离即可， TableView就比较麻烦，需要提早缓存 高度，请求数据完成后，根据数据数量与每个缓存高度，计算是否少于屏幕尺寸也做响应操作。在左右切换 ScrollView 时候，也要动态即时改变，这个是比较麻烦的坑 另外如果有更好的解决方法，欢迎留言~谢谢 Reference: 嵌套UIScrollview的滑动冲突解决方案 UIGestureRecognizer同时识别两个手势","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"Thailand Trip","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/Thailand/","text":"ThailandLoacation : 普吉岛 - 芭东海滩时间: 提早 2 小时到达机场 广州 - 曼谷出发时间 2018-06-13 02:45(北京时间) T1 出发 航班号 起飞 到达 航站楼 广州(CAN)-曼谷(DMK) (白云机场-廊曼机场) SL901 2018-06-13 02:45 2018-06-13 04:20 T1 地铁站: 机场南站 到达时间 04:20 (泰国时间) — (北京时间) 05:20全程1699公里 时长2小时35分 曼谷廊曼 - 普吉岛 出发时间 2018-06-13 06:15 (泰国时间) — (北京时间) 07:15 出发 航班号 起飞 到达 航站楼 曼谷(DMK)-普吉岛(HKT) (廊曼机场-普吉机场) SL754 2018-06-13 06:15 2018-06-13 07:40 到达时间 07:40 (泰国时间) — (北京时间) 08:40全程689公里 时长1小时25分 接送 国际航班 国内航班 【国内航站楼】到达的客人，懒猫的工作人员在国内出口的1号门外等待猫王陛下，您找到后出示确认函给工作人员看，工作人员与您核对后将在20分钟左右安排司机过来接猫王陛下， 【国际航站楼】到达的客人请您在一楼取完行李后，走出4号门，懒猫工作人员会在那边举“懒猫旅行”标识的牌等猫王陛下， 普吉岛酒店:Name : The ASHLEE Heights Patong Hotel &amp; Suites (普吉岛芭东艾希莉高地酒店) Address : Soi Nanairoumjai, Tambon Patong, Amphoe Kathu, Chang Wat Phuket 83150泰国 Tel : +66 76 358 000 路程时间大概 1小时车程 到达时间约 10:00 (泰国时间)第一天行程:到达酒店后放下行李到附近 71 刷一顿 1. 江冷购物 大概 15 分钟走路行程 价格会贵 Big c超市（价格不是很便宜）这边不是免税区，所以买了东西达到退税标准的可以开退税单到机场退税。 逛逛就好 接下来的行程自行安排，可以逛完商场附近吃东西，然后回酒店游泳睡觉下午 3.4点时候去卡伦海滩日落 2. 卡塔,卡伦海滩卡塔、卡伦海滩TUTU车到芭东海滩大约350铢，约15分钟车程 3.芭东夜市营业时间：周一到周日18:00开始到深夜卡塔、卡伦海滩出发：TUTU车大约350铢，约15分钟车程。 1.班赞海鲜1、选一家态度温和的卖家，有很多小哥特别野蛮，生拉硬拽着卖你的这种我们首轮就pass了。2、选好你想要的海鲜后，按照他给你的最终价先砍对半，这时候有可能小哥会告诉你，刚刚有个老虎蟹或者什么别的东西，忘记加进来了，记住，这是陷阱，你可以让他再重新加一遍。3、打完折后的价格再让他便宜1000B或者随你心情，总之，要砍到让他觉得很为难的时候，就算是比较合适的价格了。 我们买了六种，有大龙虾，老虎虾，老虎蟹，大扇贝，鸟贝，大皮皮虾，共计2200B，到二楼找了一家加工，六个菜，500B，端出来超级鲜亮，证明这里海鲜真的很干净新鲜哦~味道做得非常可口，这家加工店我也要推荐~ 酒吧1：Longbar Patong推荐理由：为调酒师而去相对于夜市街的嘈杂，Longbar Patong显得比较安静，吹着海风，听着音乐，有得过国际奖项的调酒师为你调制精美的酒，价格适中，服务员会中文，可以看一些足球比赛，酒吧门口正对着芭东海滩，是个休闲的理想场所。 位置：邦古拉街人均消费：￥33 - ￥118 酒吧2 : Bar Funk 3推荐理由：各种游戏、TABLE DANCE这家酒吧有很多小游戏，电视机比较多，屏幕很大，老板很友善，有时候会和游客一起玩游戏，还会有世界各地的体育直播，当然钢管舞表演也不能少，性价比较高的一家酒吧。 位置：邦古拉街人均消费：￥53 - ￥200 芭东海鲜美食广场芭东海鲜美食广场(Patong Seafood Food Court) 这里汇集了十几家海鲜餐厅，您只需选好鱼、蟹、对虾或龙虾，便可立刻为您准备好。食客们喜欢这里的原因是其很随意且友好的氛围，而菜单上通常配有菜肴的照片，价格也合理。 Sam’s Steaks &amp; Gril如果要在芭东找一不失品味的餐厅，Sam’s Steak &amp; Grill 绝对是最实至名归。位于芭东海滩假日酒店之内，Sam’s 分为露天就餐区域和室内雅间区域，中间由玻璃酒柜隔开。这家高档餐厅装饰精美、环境优雅、菜肴可口、服务周到，是安静品味美食和聊天的好地方。 推荐美食：威灵顿牛排、肉眼排、鹅肝酱位置：芭东海滩假日酒店内人均消费：200元营业时间：18:00 – 22:00 9号餐厅No 9 Restaurant非常小的店铺，主打泰国菜、日式料理和中式菜。性价比高，是当地的网红店之一。做菜的时候喜欢一桌的才全部做完一起上，这样就一定程度避免了几桌菜一起炒的现象，更加公道。 推荐：咖喱鸡、芒果糯米饭、菠萝炒饭、泰式炒河粉位置：芭东sea sun sand酒店斜对面人均消费：70元营业时间：18:00–深夜 按摩Spa 1. Orientala spa99元/人，2个小时，可以要求按摩力度，网上说的就是在 江西 冷附近，但我们走了半个小时才走到。这个spa馆还挺大的，总共两层，我们是在二楼做的，提供专门的衣服和裤子，都是很宽松的，按摩师都是女的，从脚到头给我们按摩了两个小时，特别舒服 营业时间 10：00 - 22：00 传送门 Link 2. Let’s relax马蜂窝价格 168- 500+ 传送门 Link 3. 兰花Spa (酒店附近) 价格 79 - 489 第二天行程:皇帝岛 - 珊瑚岛 - 淘宝票 传送门Link #####下午6点左右回到酒店,夜晚继续前一晚节奏 第三天行程: 泰国时间早上 9点 司机在酒店接送，7点半起床洗漱，楼下 711 解决 出发时间 2018-06-15 12:20 (泰国时间) 出发 航班号 起飞 到达 航站楼 普吉岛(HKT)-曼谷(BKK) (普吉机场-素万那普机场) VZ305 2018-06-15 12:20 2018-06-15 13:50 到达时间 2018-06-15 13:50 (泰国时间) 素万那普机场//接下来就是曼谷行程 Tips:需要带装备:驱蚊水,防晒霜，拖鞋，电动剃须刀，最好带1-2个衣架,信用卡,充电器插头(移动充,少于2w毫安),Cap帽,遮阳伞,毛巾，牙刷,牙膏,搭飞机时候的外套,最好带2套泳衣,浅色T恤(据说曼谷白天不要穿白色衣服，有降头，仅供参考),藿香正气丸，喇叭正露丸，王老吉，穿心莲，保济丸，感冒药，止血贴，etc….后续补上 需要带App:大众点评,马蜂窝,携程，Google地图,支付宝,微信 这里要告诫大家，去 泰国 一定要带常备药， 泰国 这里室外热，室内的冷气是很低的，冷热交替很容易感冒，所以藿香正气水、退烧药都得带点，毕竟外国的药我们也不敢随便吃。 如果爱喝椰子的朋友，记得要选小的，非常甜，不要选大椰子，会有些发酸哦~ 网红店差评 Reference1.芭东夜市包揽普吉岛美食购物夜生活，半城烟火都在这 2.珊瑚岛-皇帝岛","tags":[{"name":"Note","slug":"Note","permalink":"https://swlfigo.github.io/tags/Note/"}]},{"title":"iOS Extentsion 入门实战","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/TodayExtentionTrain/","text":"最近需求是App接入 Today Extentsion 组件，因为之前没做过这方面，都是摸着石头过河.以下文章都是基于摸索中遇到问题和一些总结，如果有什么不对，请指教一下~ 1. App Extensions简介1.1 什么是App Extensions从 iOS 8 开始，苹果引入了全新的 App Extension。它是一种扩展，很类似于一些大型软件的插件机制。App Extension 事实上并不是你应用的插件，而是系统的插件，其生命周期是由系统来管理的，所以如果你想做什么坏事还是行不通的…但是 App Extension 分发的载体是应用，也就是说如果你只是单纯想做一个今日面板插件，也需要有个主程序，你的主程序可以什么都不做，也可以提供一些基本的设置和数据。iOS的Extension包括以下: 文章用到的是 Today Extension,用于 iPhone 的今日插件 1.2 App Extension 和主程序的关系可以说没有什么关系，基本上就是两个独立的程序，你的主程序既不可以访问 App Extension 的代码，也不可以访问其存储空间，这完完全全就是两个进程、两个程序。 1.3 App Extension 可以干什么？不可以干什么？基本上什么都能干,但是内存有限制，App Extension 的可用内存远不如常规应用。也不能执行长时间的操作，你的 App Extension 可能随时被系统 Kill 掉,因为 App Extension 是由系统管理生命周期的。最后一些API也是不能用，一部分如下： 不能使用 sharedApplication 对象及其其中的方法。 使用NS_EXTENSION_UNAVAILABLE 宏在头文件中标记的任意API或类似的不可用的宏或API在一个不可用的框架中。例如，在iOS 8.0中，the HealthKit framework and EventKit UI framework 将不能使用app extension. 不能在iOS设备中使用相机和麦克风(不像其他app extensions，iMessage app可以访问这些资源，只有它正确的配置 NSCameraUsageDescription and NSMicrophoneUsageDescription Info.plist 文件中的Key)。 不能长期运行后台任务，该限制的具体细节因平台而异。(一个app extension能够使用NSURLSession对象启动一个上传或下载并将这些操作的结果返回给containing app) 不能使用Air Drop接收数据(一个app extension能够像一个正常的app一样通过UIActivityViewController class去使用AirDrop发送数据) 还有更多不可用的 API 可以看这个苹果官方文档（以文档为主）：Understand How an App Extension Works 1.4 App Extension 生命周期与交互因为app extension不是一个app,它的生命周期和app是不同的，在大多情况下，当用户从app的UI上或者其他活动视图控制器中选择开启extension功能的选项时将会开始执行。 先说下几个概念: App : 就是我们正常手机里的每个应用程序，即Xcode运行后生成的程序。一个app可以包含一个或多个target,每个target将产生一个product. App extension : 为了扩展特定app的功能并且依赖于一个特定的app的一条进程。 Containing app：一个app包含一个或多个extension称为containing app。 target : 在项目中新建一个target来创建app extension.任意一个target指定了应用程序中构建product的设置信息和文件。 host app : 包含app extension 并且能从中打开它(并不一定非要从此app内部打开，可以是app内部也可以是例如Today Widget外部控件)。 host app : 我们可以把它理解为宿主的App，能够调起extension的app被称为host app，比如：Safari app 里面网页分享到微信, Safari就是 host app ; widget的host app就是Today。 App Extension基本认知： Extension不能单独发布和部署，需要依赖于容器应用(Containing App)。 Extension和容器应用(Containing App)的生命周期是独立的，分别为两个不同的进程. Extension的运行依赖于宿主应用(Host App)，生命周期由宿主应用决定。 Extension作为一个单独的target存在，但会随着容器应用(Containing App)的安装和卸载而安装和卸载。 Extension需要独立的证书用来打包和测试。 1.4.1 Extension的生命周期如下: 调用起了 Extension ，操作完就退出 1.4.2 Extension 与 App 交互一些简单的交互 app extension 和 containing app将不能够直接交互，典型的，containing app可能还没有开始运行然而它包含的app extension已经在运行了。（例如，一个天气的app,当你还没有打开它时，你可以在Today Widget中看到今天天气的信息） 在一个典型的请求响应事务中，系统代表的host app打开app extension, 通过host提供的extension上下文(context)传递数据, 这个extension通过界面的展示来执行一些任务，如果适用于extension的目的，返回数据给host. 上图的虚线代表了app extension 和 containing app之间有限的交互。例如Today widget(只有 Today Extension 才支持通过调用其他不可以) 通过调用 NSExtensionContext类中openURL:completionHandler:方法来要求系统去打开它的containing app. 具体交互 任意一个app extension和它的containing app能够在一个私有的shared container中分享数据。 2. 实战要做的事情: 使用 Extensions 难免会与Containing App有一定交互或者资源共享,首先列出了可能会遇到的情景: widget 和 主 App 共用资源widget 和主 App 共享代码和资源。我们还是要尽可能的让 widget 和主 App 共享代码。因为没必要一份代码写2次，能复用就复用 主要有两个方案: framework 直接共享 widget 和 主 App 共享数据严格来说 widget 和 App 是不同的两个 App 了, 而且他们之间有沙盒限制，他们之间要共享数据的话只能使用 App Groups 了。常用就是 NSUserDefault、Core Data 、SQL 2.1 创建项目的 Extension1XCode -&gt; File -&gt; New -&gt; Target 选择 Today Extension , 项目名字随便取,当然最好就是你的跟你项目相关了,创建后可以看到，几个地方多了这个Extension 显示了: 项目中多了个文件夹，文件夹名字就是 Extension 命名的名字了 target中多了 Extension 纵观一下文件， TodayViewController是 Extension主体文件了，业务逻辑也写在里面，默认新创建的Extension是使用 .storyboard 管理UI视图的，当然你不想用也行，只需要在 Extension里的 info.plist改下 改 NSExtensionMainStoryboard字段为 NSExtensionPrincipalClass ，并修改入口为自定义类。 然后选择 scheme可以编译看下helloworld 效果了 2.2 Pod 的配置Extension开发中有时难免会用到一些第三方,如 SDWebImage 或者AFNetworking之类的，Cocoapod 也提供了这方面功能，能使 Extension 用上这些类,同理在 Podfile 中添加 1234567target 'TodayExtentsionDemo' do pod 'AFNetworking'endtarget 'TodayExtentsion' do pod 'AFNetworking'end # target写 App 与 Extension 名字即可关联 此时你也许会留意到，比如上面 AF 两个Target都要用到，都要重新写一次，会很麻烦。 是很麻烦，故此上网找了下相关解决方法，知道有个这个 link_with 方法，如下: 12link_with 'TodayExtentsionDemo', 'TodayExtentsion' pod 'AFNetworking' 但是,这种方法已经弃用了, Pod install会报错,所以你看到网上介绍相关方法的文章，都是抄别人自己又不试的 由于 Cocoapod是 Ruby 写的，我们可以这样子操作一下 12345678910111213def shareFramework pod 'AFNetworking' #blablabla Frameworkendtarget 'TodayExtentsionDemo' do shareFrameworkendtarget 'TodayExtentsion' do shareFrameworkend#定义了个Function，在里面添加通用的库 Pod install之后即可为每个 Target 引入相关库 课外阅读: Cocoapods原理总结 此时，我们可以在 Containning App 与 Extension中使用 AF库了 2.3 Extension 入门 UI 操作我们刚编译的 Extension 你会看到是没有展开按钮的，此时我们只需要在 viewDidLoad 中添加 1234567//这个iOS10以后的API，可以在Extension上显示 展开/收起 按钮, 至于iOS10 之前需要搞一个按钮手动触发改变高度?//由于手上没有 iOS10 之前机子测试, 所以先挖个坑，迟点有了再补坑if (@available(iOS 10.0, *)) &#123; self.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeExpanded; &#125;else&#123; &#125; 添加了这句代码 之后，你会发现 Extension上有了折叠收起按钮了 12345678- (void)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(CGSize)maxSize &#123; if (activeDisplayMode == NCWidgetDisplayModeExpanded) &#123; // 设置展开的新高度 //最大只能 screen size - 139 &#125;else&#123; self.preferredContentSize = maxSize; &#125;&#125; 这个是 Extension代理方法，用于回调点击了 收起/展开 按钮后，返回 显示区域的高度大小 经过一些测试，发现这个 Extension最大的高度只能是 屏幕高度 - 139. 超过了也是这么高 else 下的是收起高度，直接返回代理给你的系统 高度好了(没有特别要求的话) 123456- (void)widgetPerformUpdateWithCompletionHandler:(void (^)(NCUpdateResult))completionHandler&#123; //blablabla //做vieWillAppear前数据获取之类的操作 //或者系统每隔一段时间截取 Extension 图片时候调用的方法 completionHandler(NCUpdateResultNewData);&#125; 大致意思是建议你通过实现它的回调来获取数据，你也可以在viewwillappear中设置你的初始数据，但是希望你在获取到新数据时能平稳的过渡到新的数据来。并且它是在主线程更新。 当widget最初被创建时，widgetPerformUpdateWithCompletionHandler几乎被简单地调用，所以你可以在这里完成所有的加载，但是苹果建议你尽可能的在生命周期的早期开始加载过程。 如果您的小部件显示的信息永远不会更改，那么您不必在widgetPerformUpdateWithCompletionHandler中执行任何操作。 其实可以理解为 类似天气或者股票之类App，在用户使用时候，系统每隔一段时间会调用这个方法获取 Extension的快照，比如一段时间获得当前天气情况，更新Extension,下次你看到这个 Extension时候就是最新的天气了 2.4 Extension 与 Containing App 代码共享Extension也有UI,也有业务逻辑，有时候跟项目一些流程相同，那么代码复用也是一个考虑的点。 由于 Extension 与 Containing App 不算同一个App且同一个进程，如果要代码共享，很多人会考虑直接拷贝一份代码放到 Extension 里面(即Target选多一个Extension),比如，我们 Extension 里面需要用到一个 Tableview 显示数据，Containing App中也有相应的 Tableview 用到这个 Cell, 比如你在 Extension 里面引入这个类并且写逻辑，你会发现并不能通过编译，因为Extension 无法访问这个，此时最简单方法就是 在 Target Membership中勾选 Containning App 与 Extension 即可 但是一个问题来了,比如你这个 Cell 还引用了其他类，其他类的 Target Membership 也是需要勾选的，这样一来，项目一大你不知道有哪些勾了和没勾。这只是其中一个小问题， 另外的问题就是.如果这个文件还是主程序的 target,只要改动一下，所属的target就被编译器标记为需要重新编译，这样整个App就需要重新编译(当然你Run也是重新编译一次)，但是如果你用下面所说的 framework 苹果推荐方法，只需要编译framework里面的文件，达到组件化。我们知道cocoapod 也是将第三方库编译成 framework避免每次编译App也编译这部分东西的. 具体原理可以参考下面 文章 用 Framework 重構 Swift 程式碼 大大提高編譯效率！ 做法如下: 首先在新建一个 Framework: 1XCode -&gt; File -&gt; New -&gt; Target 通常 Framework 都以 xxxkit结尾作为标准规范,新建完成后会发现架构中多了这个Framework文件夹以及 Target 中多了一个(情况如上面新建Extension一样，不做更多截图) 第二 , 在Containning App的 Target中删除共用代码的文件 然后再 Framework的 Complie Sources 添加这个共用类 最后，在 Extension 中添加 Link Binary With Libraries 这样既可完成 Extension 与 Containing App 共用类的编译以及运行 如何解决警告linking against dylib not safe for use in application extensions: 因为app extension限制了某些API的使用， ( App Extensions不能使用的一些API ) ，因此在自定义自己的framework后，这个framework可能包含了某些在App Extensions里不能使用的API，因此为了安全起见才会给出这个警告。 选中自定义framework的target,然后选中Build Settings，（记住选择All,而不是Basic),在过滤框中输入”require only”，将Require Only App-Extension-Safe API的值改成YES，（默认为NO)，然后Command + K clean一下工程，警告久消除了。 2.5 Widget 调用 Containing App这个跟 urlScheme 设置一样，主要就是因为 Extension不能调用 [UIApplication sharedApplication] 所以正确做法是 1self.extensionContext openURL:&lt;#(nonnull NSURL *)#&gt; completionHandler:&lt;#^(BOOL success)completionHandler#&gt; 这里不做更多叙述，可以通过URL传递参数，APP动态路由处理即可 2.6 Widget 与 Containing App 数据共通严格来说 widget 和 App 是不同的两个 App 了, 他们之间要共享数据的话只能使用 App Groups 了。 具体做法忽略，暂时用个人开发者账户，之前创建的 AppGroup 发现不能删除..等上了公司证书再补坑 最后附上 Demo 地址 : Demo Reference1.揭秘 iOS App Extension 开发 —— Today 篇 2.App extension 总结 3.App Extensions Increase Your Impact 4.Understand How an App Extension Works 5.Cocoapods原理总结 6.用 Framework 重構 Swift 程式碼 大大提高編譯效率！","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"YYCache阅读学习","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/YYCacheLearn/","text":"YYCache 阅读学习官网 介绍如下： 高性能 iOS 缓存框架。YYKit 组件之一。 性能:(摘自官网)iPhone 6 上，内存缓存每秒响应次数 (越高越好): iPhone 6 上，磁盘缓存每秒响应次数 (越高越好): 特性 LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。 缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。 兼容性: API 基本和 NSCache 保持一致, 所有方法都是线程安全的。 内存缓存 对象释放控制: 对象的释放(release) 可以配置为同步或异步进行，可以配置在主线程或后台线程进行。 自动清空: 当收到内存警告或 App 进入后台时，缓存可以配置为自动清空。 磁盘缓存 可定制性: 磁盘缓存支持自定义的归档解档方法，以支持那些没有实现 NSCoding 协议的对象。 存储类型控制: 磁盘缓存支持对每个对象的存储类型 (SQLite/文件) 进行自动或手动控制，以获得更高的存取性能。 源码解析学习文中大部分为摘抄原文，然后加上自己的理解注释. 基本使用方法举一个缓存用户姓名的例子来看一下YYCache的几个API： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//需要缓存的对象 NSString *userName = @\"Jack\"; //需要缓存的对象在缓存里对应的键 NSString *key = @\"user_name\"; //创建一个YYCache实例:userInfoCache YYCache *userInfoCache = [YYCache cacheWithName:@\"userInfo\"]; //存入键值对 [userInfoCache setObject:userName forKey:key withBlock:^&#123; NSLog(@\"caching object succeed\"); &#125;]; //判断缓存是否存在 [userInfoCache containsObjectForKey:key withBlock:^(NSString * _Nonnull key, BOOL contains) &#123; if (contains)&#123; NSLog(@\"object exists\"); &#125; &#125;]; //根据key读取数据 [userInfoCache objectForKey:key withBlock:^(NSString * _Nonnull key, id&lt;NSCoding&gt; _Nonnull object) &#123; NSLog(@\"user name : %@\",object); &#125;]; //根据key移除缓存 [userInfoCache removeObjectForKey:key withBlock:^(NSString * _Nonnull key) &#123; NSLog(@\"remove user name %@\",key); &#125;]; //移除所有缓存 [userInfoCache removeAllObjectsWithBlock:^&#123; NSLog(@\"removing all cache succeed\"); &#125;]; //移除所有缓存带进度 [userInfoCache removeAllObjectsWithProgressBlock:^(int removedCount, int totalCount) &#123; NSLog(@\"remove all cache objects: removedCount :%d totalCount : %d\",removedCount,totalCount); &#125; endBlock:^(BOOL error) &#123; if(!error)&#123; NSLog(@\"remove all cache objects: succeed\"); &#125;else&#123; NSLog(@\"remove all cache objects: failed\"); &#125; &#125;]; YYCache 整体结构 YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。 YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。 _YYLinkedMap：YYMemoryCache使用的双向链表类。 _YYLinkedMapNode：是_YYLinkedMap使用的节点类。 YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。 YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。 YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。 代码阅读学习YYCacheYYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。 因为YYMemoryCache和YYDiskCache的实例作为YYCache的两个公开的属性，所以用户无法直接使用YYMemoryCache和YYDiskCache对象，只能通过属性的方式来间接使用它们。 YYCache的属性和接口123456789101112131415161718192021222324252627282930313233343536@interface YYCache : NSObject@property (copy, readonly) NSString *name;//缓存名称@property (strong, readonly) YYMemoryCache *memoryCache;//内存缓存@property (strong, readonly) YYDiskCache *diskCache;//磁盘缓存//是否包含某缓存，无回调- (BOOL)containsObjectForKey:(NSString *)key;//是否包含某缓存，有回调- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;//获取缓存对象，无回调- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;//获取缓存对象，有回调- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;//写入缓存对象，无回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;//写入缓存对象，有回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;//移除某缓存，无回调- (void)removeObjectForKey:(NSString *)key;//移除某缓存，有回调- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;//移除所有缓存，无回调- (void)removeAllObjects;//移除所有缓存，有回调- (void)removeAllObjectsWithBlock:(void(^)(void))block;//移除所有缓存，有进度和完成的回调- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;@end YYCache的接口实现12345678910111213141516171819202122232425262728293031323334353637383940- (BOOL)containsObjectForKey:(NSString *)key &#123; //先检查内存缓存是否存在，再检查磁盘缓存是否存在 return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];&#125;- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; //首先尝试获取内存缓存，然后获取磁盘缓存 id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; //如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil if (!object) &#123; object = [_diskCache objectForKey:key]; if (object) &#123; [_memoryCache setObject:object forKey:key]; &#125; &#125; return object;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; //先写入内存缓存，后写入磁盘缓存 [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key];&#125;- (void)removeObjectForKey:(NSString *)key &#123; //先移除内存缓存，后移除磁盘缓存 [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key];&#125;- (void)removeAllObjects &#123; //先全部移除内存缓存，后全部移除磁盘缓存 [_memoryCache removeAllObjects]; [_diskCache removeAllObjects];&#125; 从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。 在读取缓存的操作中，如果在内存缓存中无法获取对应的缓存，则会去磁盘缓存中寻找。如果在磁盘缓存中找到了对应的缓存，则会将该对象再次写入内存缓存中，保证在下一次尝试获取同一缓存时能够在内存中就能返回，提高速度。 YYMemoryCacheNSCache 内存缓存不足通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。相对于磁盘缓存来说，内存缓存的设计要更简单些，下面是我调查的一些常见的内存缓存。 NSCache 是苹果提供的一个简单的内存缓存，它有着和 NSDictionary 类似的 API，不同点是它是线程安全的，并且不会 retain key。我在测试时发现了它的几个特点：NSCache 底层并没有用 NSDictionary 等已有的类，而是直接调用了 libcache.dylib，其中线程安全是由 pthread_mutex 完成的。另外，它的性能和 key 的相似度有关，如果有大量相似的 key (比如 “1”, “2”, “3”, …)，NSCache 的存取性能会下降得非常厉害，大量的时间被消耗在 CFStringEqual() 上，不知这是不是 NSCache 本身设计的缺陷。 YYMemoryCacheYYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。但是与NSCache不同的是，YYMemoryCache的内部有： 缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。 缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。 一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下：缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低。 缓存清理维度是给每个缓存添加的标记： 如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。 如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。 如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。 可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略： YYMemoryCache的缓存淘汰算法LRU算法 在YYMemoryCache中，使用了双向链表这个数据结构来保存这些缓存： 当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。 当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。 (根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。 这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。 YYMemoryCache用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点。这两个类的名称分别是： _YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。 _YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点) _YYLinkedMapNode_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。 123456789101112@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; //缓存key id _value; //key对应值 NSUInteger _cost; //缓存开销 NSTimeInterval _time; //访问时间 &#125;@end 双向链表类: _YYLinkedMap123456789101112131415161718192021222324252627@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 用于存放节点 NSUInteger _totalCost; //总开销 NSUInteger _totalCount; //节点总数 _YYLinkedMapNode *_head; // 链表的头部结点 _YYLinkedMapNode *_tail; // 链表的尾部节点 BOOL _releaseOnMainThread; //是否在主线程释放，默认为NO BOOL _releaseAsynchronously; //是否在子线程释放，默认为YES&#125;//在链表头部插入某节点- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;//将链表内部的某个节点移到链表头部- (void)bringNodeToHead:(_YYLinkedMapNode *)node;//移除某个节点- (void)removeNode:(_YYLinkedMapNode *)node;//移除链表的尾部节点并返回它- (_YYLinkedMapNode *)removeTailNode;//移除所有节点（默认在子线程操作）- (void)removeAll;@end 从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。 可以参考下面这张图来看一下二者的关系： PS:(阅读注) _YYLinkedMap 类中有一个有一个字典记录着缓存对象信息,分别是 Key 与 Node对象, 包括了一个头结点与尾节点的 Node,形成了一个OC版链表, _YYLinkedMap的接口的实现：将节点插入到链表头部： 1234567891011121314151617181920212223242526- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; //设置该node的值 CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); //增加开销和总缓存数量 _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; //如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点） node-&gt;_next = _head; //将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点） _head-&gt;_prev = node; //将该节点赋给链表的头结点指针（该节点变成了现第一个节点） _head = node; &#125; else &#123; //如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点 _head = _tail = node; &#125;&#125; 要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中： 每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。 链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。 为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们：每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手；而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。 PS:(阅读注)C 中的链表，头结点指向上一个节点的尾节点,尾节点指向下一个节点的头结点. 如果 插入时候，会判断缓存字典里面有没有数据，有的话，拿出来插到链表第一位，然后将原来位置的前后节点连接起来 将某个节点移动到链表头部： 12345678910111213141516171819202122232425262728293031323334353637- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123; //如果该节点已经是链表头部节点，则立即返回，不做任何操作 if (_head == node) return; if (_tail == node) &#123; //如果该节点是链表的尾部节点 //1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点） _tail = node-&gt;_prev; //2. 将新的尾部节点的尾部指针置空 _tail-&gt;_next = nil; &#125; else &#123; //如果该节点是链表头部和尾部以外的节点（中间节点） //1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针 node-&gt;_next-&gt;_prev = node-&gt;_prev; //2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针 node-&gt;_prev-&gt;_next = node-&gt;_next; &#125; //将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点） node-&gt;_next = _head; //将当前节点的头节点置空 node-&gt;_prev = nil; //将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点） _head-&gt;_prev = node; //将该节点设置为链表的头节点 _head = node;&#125; 再结合链表的图解来看一下： 移除链表中的某个节点： 12345678910111213141516171819202122- (void)removeNode:(_YYLinkedMapNode *)node &#123; //除去该node的键对应的值 CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); //减去开销和总缓存数量 _totalCost -= node-&gt;_cost; _totalCount--; //节点操作 //1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针 if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; //2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针 if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; //3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一） if (_head == node) _head = node-&gt;_next; //4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一） if (_tail == node) _tail = node-&gt;_prev;&#125; 移除并返回尾部的node: 123456789101112131415161718192021222324252627- (_YYLinkedMapNode *)removeTailNode &#123; //如果不存在尾节点，则返回nil if (!_tail) return nil; _YYLinkedMapNode *tail = _tail; //移除尾部节点对应的值 CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key)); //减少开销和总缓存数量 _totalCost -= _tail-&gt;_cost; _totalCount--; if (_head == _tail) &#123; //如果链表的头尾节点相同，说明链表只有一个节点。将其置空 _head = _tail = nil; &#125; else &#123; //将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一） _tail = _tail-&gt;_prev; //将新的尾节点的尾指针置空 _tail-&gt;_next = nil; &#125; return tail;&#125; YYMemoryCache的属性和接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//YYMemoryCache.h@interface YYMemoryCache : NSObject#pragma mark - Attribute//缓存名称，默认为nil@property (nullable, copy) NSString *name;//缓存总数量@property (readonly) NSUInteger totalCount;//缓存总开销@property (readonly) NSUInteger totalCost;#pragma mark - Limit//数量上限，默认为NSUIntegerMax，也就是无上限@property NSUInteger countLimit;//开销上限，默认为NSUIntegerMax，也就是无上限@property NSUInteger costLimit;//缓存时间上限，默认为DBL_MAX，也就是无上限@property NSTimeInterval ageLimit;//清理超出上限之外的缓存的操作间隔时间，默认为5s@property NSTimeInterval autoTrimInterval;//收到内存警告时是否清理所有缓存，默认为YES@property BOOL shouldRemoveAllObjectsOnMemoryWarning;//app进入后台是是否清理所有缓存，默认为YES@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;//收到内存警告的回调block@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);//进入后台的回调block@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);//缓存清理是否在后台进行，默认为NO@property BOOL releaseOnMainThread;//缓存清理是否异步执行，默认为YES@property BOOL releaseAsynchronously;#pragma mark - Access Methods//是否包含某个缓存- (BOOL)containsObjectForKey:(id)key;//获取缓存对象- (nullable id)objectForKey:(id)key;//写入缓存对象- (void)setObject:(nullable id)object forKey:(id)key;//写入缓存对象，并添加对应的开销- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;//移除某缓存- (void)removeObjectForKey:(id)key;//移除所有缓存- (void)removeAllObjects;#pragma mark - Trim// =========== 缓存清理接口 =========== //清理缓存到指定个数- (void)trimToCount:(NSUInteger)count;//清理缓存到指定开销- (void)trimToCost:(NSUInteger)cost;//清理缓存时间小于指定时间的缓存- (void)trimToAge:(NSTimeInterval)age; YYMemoryCache的接口实现在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。 123456- (instancetype)init&#123; .... _lru = [_YYLinkedMap new]; ... &#125; 然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//是否包含某个缓存对象- (BOOL)containsObjectForKey:(id)key &#123; //尝试从内置的字典中获得缓存对象 if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;//获取某个缓存对象- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //如果节点存在，则更新它的时间信息（最后一次访问的时间） node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;//写入某个缓存对象，开销默认为0- (void)setObject:(id)object forKey:(id)key &#123; [self setObject:object forKey:key withCost:0];&#125;//写入某个缓存对象，并存入缓存开销- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; if (!key) return; if (!object) &#123; [self removeObjectForKey:key]; return; &#125; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; //如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部 //更新总cost _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; //更新node node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; //将node移动至链表头部 [_lru bringNodeToHead:node]; &#125; else &#123; //如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部 //新建node,并赋值 node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; //将node插入至链表头部 [_lru insertNodeAtHead:node]; &#125; //如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求） if (_lru-&gt;_totalCost &gt; _costLimit) &#123; dispatch_async(_queue, ^&#123; [self trimToCost:_costLimit]; &#125;); &#125; //如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可） if (_lru-&gt;_totalCount &gt; _countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;//移除某个缓存对象- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //内部调用了链表的removeNode：方法 [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;//内部调用了链表的removeAll方法- (void)removeAllObjects &#123; pthread_mutex_lock(&amp;_lock); [_lru removeAll]; pthread_mutex_unlock(&amp;_lock);&#125; 上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。 YYMemoryCache的缓存清理策略在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。 缓存自动清理 缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142//YYMemoryCache.m- (instancetype)init&#123; ... //开始定期清理 [self _trimRecursively]; ...&#125;//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行- (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; //在后台进行清理操作 [self _trimInBackground]; //调用自己，递归操作 [self _trimRecursively]; &#125;);&#125;//清理所有不符合限制的缓存，顺序为：cost，count，age- (void)_trimInBackground &#123; dispatch_async(_queue, ^&#123; [self _trimToCost:self-&gt;_costLimit]; [self _trimToCount:self-&gt;_countLimit]; [self _trimToAge:self-&gt;_ageLimit]; &#125;);&#125; 12345678910111213141516//YYMemoryCache.m- (void)trimToCount:(NSUInteger)count &#123; if (count == 0) &#123; [self removeAllObjects]; return; &#125; [self _trimToCount:count];&#125;- (void)trimToCost:(NSUInteger)cost &#123; [self _trimToCost:cost];&#125;- (void)trimToAge:(NSTimeInterval)age &#123; [self _trimToAge:age];&#125; 可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。 YYDiskCacheYYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是： 都具有查询，写入，读取，删除缓存的接口。 不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。 它使用LRU算法来清理缓存。 支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。 它与YYMemoryCache不同点是： 根据缓存数据的大小来采取不同的形式的缓存： 数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。 文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。 除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。 123456789101112131415161718192021222324252627282930313233343536373839404142//YYDiskCache.h- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key, BOOL contains))block;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id&lt;NSCoding&gt; _Nullable object))block;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void(^)(void))block;- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key))block;- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;- (NSInteger)totalCount;- (void)totalCountWithBlock:(void(^)(NSInteger totalCount))block;- (NSInteger)totalCost;- (void)totalCostWithBlock:(void(^)(NSInteger totalCost))block;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count;- (void)trimToCount:(NSUInteger)count withBlock:(void(^)(void))block;- (void)trimToCost:(NSUInteger)cost;- (void)trimToCost:(NSUInteger)cost withBlock:(void(^)(void))block;- (void)trimToAge:(NSTimeInterval)age;- (void)trimToAge:(NSTimeInterval)age withBlock:(void(^)(void))block; 上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它作为用sqlite做缓存还是用文件做缓存的分水岭： 12//YYDiskCache.h@property (readonly) NSUInteger inlineThreshold; 这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。 1234567891011121314151617//YYDiskCache.m- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; ... NSString *filename = nil; if (_kv.type != YYKVStorageTypeSQLite) &#123; //如果长度大临界值，则生成文件名称，使得filename不为nil if (value.length &gt; _inlineThreshold) &#123; filename = [self _filenameForKey:key]; &#125; &#125; Lock(); //在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存 [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData]; Unlock();&#125; YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值： 12345678910//YYDiskCache.m- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; _kv = kv; ...&#125; 1234567891011121314- (BOOL)containsObjectForKey:(NSString *)key &#123; if (!key) return NO; Lock(); BOOL contains = [_kv itemExistsForKey:key]; Unlock(); return contains;&#125;- (void)removeObjectForKey:(NSString *)key &#123; if (!key) return; Lock(); [_kv removeItemForKey:key]; Unlock();&#125; YYKVStorageYYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)： 12345678910111213//YYKVStorageItem.h@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; //键@property (nonatomic, strong) NSData *value; //值@property (nullable, nonatomic, strong) NSString *filename; //文件名@property (nonatomic) int size; //值的大小，单位是byte@property (nonatomic) int modTime; //修改时间戳@property (nonatomic) int accessTime; //最后访问的时间戳@property (nullable, nonatomic, strong) NSData *extendedData; //extended data@end PS:阅读注 YYKVStorageItem 作为一个存储文件对象类，记录了文件信息，获取时候，从数据库读取文件信息，赋值然后返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//YYKVStorage.h//写入某个item- (BOOL)saveItem:(YYKVStorageItem *)item;//写入某个键值对，值为NSData对象- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;//写入某个键值对，包括文件名以及data信息- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(nullable NSString *)filename extendedData:(nullable NSData *)extendedData;#pragma mark - Remove Items//移除某个键的item- (BOOL)removeItemForKey:(NSString *)key;//移除多个键的item- (BOOL)removeItemForKeys:(NSArray&lt;NSString *&gt; *)keys;//移除大于参数size的item- (BOOL)removeItemsLargerThanSize:(int)size;//移除时间早于参数时间的item- (BOOL)removeItemsEarlierThanTime:(int)time;//移除item，使得缓存总容量小于参数size- (BOOL)removeItemsToFitSize:(int)maxSize;//移除item，使得缓存数量小于参数size- (BOOL)removeItemsToFitCount:(int)maxCount;//移除所有的item- (BOOL)removeAllItems;//移除所有的item，附带进度与结束block- (void)removeAllItemsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;#pragma mark - Get Items//读取参数key对应的item- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;//读取参数key对应的data- (nullable NSData *)getItemValueForKey:(NSString *)key;//读取参数数组对应的item数组- (nullable NSArray&lt;YYKVStorageItem *&gt; *)getItemForKeys:(NSArray&lt;NSString *&gt; *)keys;//读取参数数组对应的item字典- (nullable NSDictionary&lt;NSString *, NSData *&gt; *)getItemValueForKeys:(NSArray&lt;NSString *&gt; *)keys; 1234567891011//写入某个item- (BOOL)saveItem:(YYKVStorageItem *)item;//写入某个键值对，值为NSData对象- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;//写入某个键值对，包括文件名以及data信息- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(nullable NSString *)filename extendedData:(nullable NSData *)extendedData; 这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。 首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。 再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。 判断filename是否为空字符串： 如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。 如果为空： 如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除 如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (BOOL)saveItem:(YYKVStorageItem *)item &#123; return [self saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value &#123; return [self saveItemWithKey:key value:value filename:nil extendedData:nil];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123; if (key.length == 0 || value.length == 0) return NO; if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) &#123; return NO; &#125; if (filename.length) &#123; //如果文件名不为空字符串，说明要进行文件缓存 if (![self _fileWriteWithName:filename data:value]) &#123; return NO; &#125; //写入元数据 if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123; //如果缓存信息保存失败，则删除对应的文件 [self _fileDeleteWithName:filename]; return NO; &#125; return YES; &#125; else &#123; //如果文件名为空字符串，说明不要进行文件缓存 if (_type != YYKVStorageTypeSQLite) &#123; //如果缓存类型不是数据库缓存，则查找出相应的文件名并删除 NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; &#125; // 缓存类型是数据库缓存，把元数据和value写入数据库 return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData]; &#125;&#125; 从上面的代码可以看出，在底层写入缓存的方法是_dbSaveWithKey:value:fileName:extendedData:，这个方法使用了两次: 在以文件（和数据库）存储缓存时 在以数据库存储缓存时 不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下_dbSaveWithKey:value:fileName:extendedData:内部是如何区分有无filename的情况的： 当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里 当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//数据库存储- (BOOL)_dbSaveWithKey:(NSString *)key value:(NSData *)value fileName:(NSString *)fileName extendedData:(NSData *)extendedData &#123; //sql语句 NSString *sql = @\"insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);\"; sqlite3_stmt *stmt = [self _dbPrepareStmt:sql]; if (!stmt) return NO; int timestamp = (int)time(NULL); //key sqlite3_bind_text(stmt, 1, key.UTF8String, -1, NULL); //filename sqlite3_bind_text(stmt, 2, fileName.UTF8String, -1, NULL); //size sqlite3_bind_int(stmt, 3, (int)value.length); //inline_data if (fileName.length == 0) &#123; //如果文件名长度==0，则将value存入数据库 sqlite3_bind_blob(stmt, 4, value.bytes, (int)value.length, 0); &#125; else &#123; //如果文件名长度不为0，则不将value存入数据库 sqlite3_bind_blob(stmt, 4, NULL, 0, 0); &#125; //modification_time sqlite3_bind_int(stmt, 5, timestamp); //last_access_time sqlite3_bind_int(stmt, 6, timestamp); //extended_data sqlite3_bind_blob(stmt, 7, extendedData.bytes, (int)extendedData.length, 0); int result = sqlite3_step(stmt); if (result != SQLITE_DONE) &#123; if (_errorLogsEnabled) NSLog(@\"%s line:%d sqlite insert error (%d): %s\", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); return NO; &#125; return YES;&#125; 再来看一下获取缓存的操作： 1234567891011121314151617181920212223//YYKVSorage.m- (YYKVStorageItem *)getItemForKey:(NSString *)key &#123; if (key.length == 0) return nil; YYKVStorageItem *item = [self _dbGetItemWithKey:key excludeInlineData:NO]; if (item) &#123; //更新内存访问的时间 [self _dbUpdateAccessTimeWithKey:key]; if (item.filename) &#123; //如果有文件名，则尝试获取文件数据 item.value = [self _fileReadWithName:item.filename]; //如果此时获取文件数据失败，则删除对应的item if (!item.value) &#123; [self _dbDeleteItemWithKey:key]; item = nil; &#125; &#125; &#125; return item;&#125; 从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是_dbGetItemWithKey:excludeInlineData:我们来看一下它的实现： 首先根据查找key的sql语句生成stmt 然后将传入的key与该stmt进行绑定 最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。 123456789101112131415161718- (YYKVStorageItem *)_dbGetItemWithKey:(NSString *)key excludeInlineData:(BOOL)excludeInlineData &#123; NSString *sql = excludeInlineData ? @\"select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;\" : @\"select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;\"; sqlite3_stmt *stmt = [self _dbPrepareStmt:sql]; if (!stmt) return nil; sqlite3_bind_text(stmt, 1, key.UTF8String, -1, NULL); YYKVStorageItem *item = nil; int result = sqlite3_step(stmt); if (result == SQLITE_ROW) &#123; //传入stmt来生成YYKVStorageItem实例 item = [self _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData]; &#125; else &#123; if (result != SQLITE_DONE) &#123; if (_errorLogsEnabled) NSLog(@\"%s line:%d sqlite query error (%d): %s\", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); &#125; &#125; return item;&#125; 最终生成YYKVStorageItem实例的是通过_dbGetItemFromStmt:excludeInlineData:来实现的： 1234567891011121314151617181920212223242526272829- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(BOOL)excludeInlineData &#123; //提取数据 int i = 0; char *key = (char *)sqlite3_column_text(stmt, i++); char *filename = (char *)sqlite3_column_text(stmt, i++); int size = sqlite3_column_int(stmt, i++); //判断excludeInlineData const void *inline_data = excludeInlineData ? NULL : sqlite3_column_blob(stmt, i); int inline_data_bytes = excludeInlineData ? 0 : sqlite3_column_bytes(stmt, i++); int modification_time = sqlite3_column_int(stmt, i++); int last_access_time = sqlite3_column_int(stmt, i++); const void *extended_data = sqlite3_column_blob(stmt, i); int extended_data_bytes = sqlite3_column_bytes(stmt, i++); //将数据赋给item的属性 YYKVStorageItem *item = [YYKVStorageItem new]; if (key) item.key = [NSString stringWithUTF8String:key]; if (filename &amp;&amp; *filename != 0) item.filename = [NSString stringWithUTF8String:filename]; item.size = size; if (inline_data_bytes &gt; 0 &amp;&amp; inline_data) item.value = [NSData dataWithBytes:inline_data length:inline_data_bytes]; item.modTime = modification_time; item.accessTime = last_access_time; if (extended_data_bytes &gt; 0 &amp;&amp; extended_data) item.extendedData = [NSData dataWithBytes:extended_data length:extended_data_bytes]; return item;&#125; 上面这段代码分为两个部分： 获取数据库里每一个字段对应的数据 将数据赋给YYKVStorageItem的实例 需要注意的是： 字符串类型需要使用stringWithUTF8String:来转成NSString类型。 这里面会判断excludeInlineData： 如果为TRUE，就提取存入的data数据 如果为FALSE，就不提取 保证线程安全的方案对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的由上文可以看出： YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全 YYDiskCache 则选择了更适合它的 dispatch_semaphore。 内存缓存操作的互斥锁在YYMemoryCache中，是使用互斥锁来保证线程安全的。 首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。 12345678910111213141516171819202122232425262728293031323334353637- (NSUInteger)totalCost &#123; pthread_mutex_lock(&amp;_lock); NSUInteger totalCost = _lru-&gt;_totalCost; pthread_mutex_unlock(&amp;_lock); return totalCost;&#125;- (void)setReleaseOnMainThread:(BOOL)releaseOnMainThread &#123; pthread_mutex_lock(&amp;_lock); _lru-&gt;_releaseOnMainThread = releaseOnMainThread; pthread_mutex_unlock(&amp;_lock);&#125;- (BOOL)containsObjectForKey:(id)key &#123; if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //如果节点存在，则更新它的时间信息（最后一次访问的时间） node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125; 而且需要在dealloc方法中销毁这个锁头： 1234567- (void)dealloc &#123; ... //销毁互斥锁 pthread_mutex_destroy(&amp;_lock);&#125; 磁盘缓存使用信号量来代替锁123456- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... _lock = dispatch_semaphore_create(1); _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT); ... 然后使用了宏来代替加锁解锁的代码 12#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)#define Unlock() dispatch_semaphore_signal(self-&gt;_lock) 信号量:dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是 dispatch_semaphore_create：定义信号量 dispatch_semaphore_signal：使信号量+1 dispatch_semaphore_wait：使信号量-1 当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能： 执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。 此时如果其他线程过来访问这段代码，就要让其等待。 当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。 如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。 这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。 PS:(互斥锁与信号量区别) “信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在 哪里）。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这 个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的”也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务 并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进 行操作。在有些情况下两者可以互换。 更形象表达: 虽然 Mutex和Semaphore 在一定程度上可以互相替代，比如你可以把 值最大为1 的Semaphore当Mutex用，也可以用Mutex＋计数器当Semaphore。但是对于设计理念上还是有不同的，Mutex管理的是资源的使用权，而Semaphore管理的是资源的数量，有那么一点微妙的小区别。打个比方，在早餐餐厅，大家要喝咖啡。如果用Mutex的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。如果用Semaphore的模式，服务员会把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。 使用锁思路为什么内存缓存使用互斥锁（pthread_mutex）？框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。 为什么磁盘缓存使用的是信号量（dispatch_semaphore）？ dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。 因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。 提高缓存性能的几个尝试选择合适的线程锁如上所说 选择合适的数据结构在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？ 为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。 为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。 选择合适的线程来操作不同的任务无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做： 看一下释放所有内存缓存的操作： 12345678910111213141516171819202122232425262728293031323334353637- (void)removeAll &#123; //将开销，缓存数量置为0 _totalCost = 0; _totalCount = 0; //将链表的头尾节点置空 _head = nil; _tail = nil; if (CFDictionaryGetCount(_dic) &gt; 0) &#123; CFMutableDictionaryRef holder = _dic; _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); //是否在子线程操作 if (_releaseAsynchronously) &#123; dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else &#123; CFRelease(holder); &#125; &#125;&#125;//内联函数，返回优先级最低的全局并发队列static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; 选择底层的类同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。 异步释放对象的技巧为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子： 首先将这个缓存的node类取出，然后异步将其释放掉。 12345678910111213141516171819202122- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; //重点部分 [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //重点部分 [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125; 为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了class这个消息。 PS 阅读理解 这个线程释放，按我的理解就是，node在执行这个方法后出了作用域，reference 减一，但是block里面调用node，使node 被这个queue Hold 住，reference 加一, 那么，执行完这个block之后，reference count 减一，就达到了再对应线程里面释放目的.如有不对，请指点一下 Reference: YYCache官网 YYCache 设计思路 知乎回答 - 信号量与互斥锁区别 CSDN - 信号量与互斥锁区别 YYCache源码解析","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"YYModel阅读学习","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/YYModelLearn/","text":"YYModel 阅读学习YYModel 是 YYKit 中其中一个部件，作用于Model对象转换.YYModel有比大多数同类框架，有着很好的性能优势（下图为作者在github的贴图）文中大部分为摘抄原文，然后加上自己的理解注释. YYModel 使用YYModel的使用相对于JSOMModel更佳简单，不需要类去继承JSONModel. 如果有这样一组json数据： 12345&#123;\"number\":\"13612345678\", \"name\":\"Germany\", \"age\": 49&#125; 那我们会去建立相应的Object对象 12345@interface TestObject : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *number;@property (nonatomic, assign) NSInteger age;@end 调用 12345// 从 JSON 转为 Model:TestObject *testObject = [TestObject yy_modelWithJSON:json];//从 Model 转为 JSON:NSDictionary *json = [testObject yy_modelToJSONObject]; 整体结构 包括: 文件YYModel.h: 导入YYModel头文件 文件NSObject+YYModel: YYModel主体Category 文件YYClassInfo:Class解析类 文件 YYClassInfo 中包括: @interface YYClassIvarInfo : NSObject 对Class的Ivar进行解析与构造 @interface YYClassMethodInfo : NSObject 对Class的Method进行解析与构造 @interface YYClassPropertyInfo : NSObject 对Class的Property进行解析与构造 @interface YYClassInfo : NSObject 通过以上三种解析，对Class进行解析与构造 文件 NSObject+YYModel 中包含： @interface _YYModelPropertyMeta : NSObject 对Model的property进行解析与构造(.m中的private类) @interface _YYModelMeta : NSObject 对Model进行解析与构造(.m中的private类) @interface NSObject (YYModel) NSObject的YYModel Category @interface NSArray (YYModel) NSArray的YYModel Category @interface NSDictionary (YYModel) NSDictionary的YYModel Category @protocol YYModel &lt;NSObject&gt; 接口YYModel 大体思路12345//先转化json对象到dictionary，再调用yy_modelWithDictionary+ (instancetype)yy_modelWithJSON:(id)json &#123; NSDictionary *dic = [self _yy_dictionaryWithJSON:json]; return [self yy_modelWithDictionary:dic];&#125; 其中 _yy_dictionaryWithJSON 就是将id的JSON对象转成dictionary 1234567891011121314151617+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json &#123; if (!json || json == (id)kCFNull) return nil; NSDictionary *dic = nil; NSData *jsonData = nil; if ([json isKindOfClass:[NSDictionary class]]) &#123; dic = json; &#125; else if ([json isKindOfClass:[NSString class]]) &#123; jsonData = [(NSString *)json dataUsingEncoding : NSUTF8StringEncoding]; &#125; else if ([json isKindOfClass:[NSData class]]) &#123; jsonData = json; &#125; if (jsonData) &#123; dic = [NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:NULL]; if (![dic isKindOfClass:[NSDictionary class]]) dic = nil; &#125; return dic;&#125; 赋值 123456789101112131415161718//解析model属性并附值+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123; if (!dictionary || dictionary == (id)kCFNull) return nil; if (![dictionary isKindOfClass:[NSDictionary class]]) return nil; Class cls = [self class]; //解析class得到modelmeta对象 _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls]; //本地class类型映射 if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123; cls = [cls modelCustomClassForDictionary:dictionary] ?: cls; &#125; NSObject *one = [cls new]; //附值函数 if ([one yy_modelSetWithDictionary:dictionary]) return one; return nil;&#125; Runtime 说起理解instance、class object、metaclass instance 对象实例 我们经常使用id来声明一个对象，那id的本质又是什么呢？打开 #import&lt;objc/objc.h&gt;文件，可以发现以下几行代码 12345678910/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 通过注释和代码，创建的一个对象或实例其实就是一个struct objc_object结构体，而我们常用的id也就是这个结构体的指针。这个结构体只有一个成员变量，这是一个Class类型的变量isa，也是一个结构体指针。面向对象中每一个对象都必须依赖一个类来创建，因此对象的isa指针就指向对象所属的类根据这个类模板能够创建出实例变量、实例方法等。 比如有如下代码: 1NSString* str = @\"Hello World\"; 通过上文我们知道这个str对象本质就是一个objc_object结构体，而这个结构体的成员变量isa指针则表明了str is a NSString，因此这个isa就指向了NSString类，这个NSString类其实是类对象。 class object/metaclass 继续查看结构体objc_class的定义 1234567891011121314151617struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ struct objc_classs 结构体里存放的数据称为元数据(metadata)，通过成员变量的名称我们可以猜测里面存放有指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，这些信息就足够创建一个实例了，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例，因此前文中的栗子其实应该表达为str的isa指针指向了NSString类对象,那么这个结构体的isa指针又指向什么呢？类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 通过上图我们可以清晰的看出来一个实例对象也就是struct objc_object结构体它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了什么,引用一张网上经常看到的图: 通过上图我们可以看出整个体系构成了一个自闭环，如果是从NSObject中继承而来的上图中的Root class就是NSObject。至此，整个实例、类对象、元类的概念也就讲清了 概念引用 类对象有如下代码: 123456789101112131415161718192021222324@interface Person : NSObject@property (nonatomic, copy) NSString* name;@property (nonatomic, assign) NSUInteger age;@end@implementation Person@synthesize name = _name;@synthesize age = _age;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; Class c1 = [p class]; Class c2 = [Person class]; //输出 1 NSLog(@\"%d\", c1 == c2); &#125; return 0;&#125; c1是通过一个实例对象获取的Class，实例对象可以获取到其类对象，类名作为消息的接受者时代表的是类对象，因此类对象获取Class得到的是其本身，同时也印证了类对象是一个单例的想法。 如何获得 isa 指针的指向对象介绍两个函数 12345OBJC_EXPORT BOOL class_isMetaClass(Class cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);OBJC_EXPORT Class object_getClass(id obj) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); class_isMetaClass用于判断Class对象是否为元类，object_getClass用于获取对象的isa指针指向的对象。 再看如下代码: 1234567891011121314int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; //输出1 NSLog(@\"%d\", [p class] == object_getClass(p)); //输出0 NSLog(@\"%d\", class_isMetaClass(object_getClass(p))); //输出1 NSLog(@\"%d\", class_isMetaClass(object_getClass([Person class]))); //输出0 NSLog(@\"%d\", object_getClass(p) == object_getClass([Person class])); &#125; return 0;&#125; 通过代码可以看出，一个实例对象通过class方法获取的Class就是它的isa指针指向的类对象，而类对象不是元类，类对象的isa指针指向的对象是元类。 回到YYModel - YYClassInfo####1. typedef NS_OPTIONS(NSUInteger, YYEncodingType) 与 YYEncodingType YYEncodingGetType(const char *typeEncoding)方法 Type Encodings: To assist the runtime system, the compiler encodes the return and argument types for each method in a character string and associates the string with the method selector. The coding scheme it uses is also useful in other contexts and so is made publicly available with the @encode() compiler directive. When given a type specification, @encode() returns a string encoding that type. The type can be a basic type such as an int, a pointer, a tagged structure or union, or a class name—any type, in fact, that can be used as an argument to the C sizeof() operator. property attribute的解析就是通过type encode解析出来的string进行的解析。 附上苹果官网一张encode图: 在 YYClassInfo.h 中，先定义了一个 NS_OPTIONS ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef NS_OPTIONS(NSUInteger, YYEncodingType) &#123; //0~8位：变量类型 YYEncodingTypeMask = 0xFF, ///&lt; mask of type value YYEncodingTypeUnknown = 0, ///&lt; unknown YYEncodingTypeVoid = 1, ///&lt; void YYEncodingTypeBool = 2, ///&lt; bool YYEncodingTypeInt8 = 3, ///&lt; char / BOOL YYEncodingTypeUInt8 = 4, ///&lt; unsigned char YYEncodingTypeInt16 = 5, ///&lt; short YYEncodingTypeUInt16 = 6, ///&lt; unsigned short YYEncodingTypeInt32 = 7, ///&lt; int YYEncodingTypeUInt32 = 8, ///&lt; unsigned int YYEncodingTypeInt64 = 9, ///&lt; long long YYEncodingTypeUInt64 = 10, ///&lt; unsigned long long YYEncodingTypeFloat = 11, ///&lt; float YYEncodingTypeDouble = 12, ///&lt; double YYEncodingTypeLongDouble = 13, ///&lt; long double YYEncodingTypeObject = 14, ///&lt; id YYEncodingTypeClass = 15, ///&lt; Class YYEncodingTypeSEL = 16, ///&lt; SEL YYEncodingTypeBlock = 17, ///&lt; block YYEncodingTypePointer = 18, ///&lt; void* YYEncodingTypeStruct = 19, ///&lt; struct YYEncodingTypeUnion = 20, ///&lt; union YYEncodingTypeCString = 21, ///&lt; char* YYEncodingTypeCArray = 22, ///&lt; char[10] (for example) //8~16位：方法类型 YYEncodingTypeQualifierMask = 0xFF00, ///&lt; mask of qualifier YYEncodingTypeQualifierConst = 1 &lt;&lt; 8, ///&lt; const YYEncodingTypeQualifierIn = 1 &lt;&lt; 9, ///&lt; in YYEncodingTypeQualifierInout = 1 &lt;&lt; 10, ///&lt; inout YYEncodingTypeQualifierOut = 1 &lt;&lt; 11, ///&lt; out YYEncodingTypeQualifierBycopy = 1 &lt;&lt; 12, ///&lt; bycopy YYEncodingTypeQualifierByref = 1 &lt;&lt; 13, ///&lt; byref YYEncodingTypeQualifierOneway = 1 &lt;&lt; 14, ///&lt; oneway //16~24位：property修饰类型 YYEncodingTypePropertyMask = 0xFF0000, ///&lt; mask of property YYEncodingTypePropertyReadonly = 1 &lt;&lt; 16, ///&lt; readonly YYEncodingTypePropertyCopy = 1 &lt;&lt; 17, ///&lt; copy YYEncodingTypePropertyRetain = 1 &lt;&lt; 18, ///&lt; retain YYEncodingTypePropertyNonatomic = 1 &lt;&lt; 19, ///&lt; nonatomic YYEncodingTypePropertyWeak = 1 &lt;&lt; 20, ///&lt; weak YYEncodingTypePropertyCustomGetter = 1 &lt;&lt; 21, ///&lt; getter= YYEncodingTypePropertyCustomSetter = 1 &lt;&lt; 22, ///&lt; setter= YYEncodingTypePropertyDynamic = 1 &lt;&lt; 23, ///&lt; @dynamic&#125;; NS_OPTIONS 主要定义了3个大类encode type: YYEncodingTypeMask:变量类型，因为类型只会有一种，所以就用数字占位 YYEncodingTypeQualifierMask:方法中的参数变量修饰符，理论上只有解析Method的参数才能解析到 YYEncodingTypePropertyMaskproperty修饰符类型 获取Ivar类型的函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//解析Ivar的type encode stringYYEncodingType YYEncodingGetType(const char *typeEncoding) &#123; char *type = (char *)typeEncoding; if (!type) return YYEncodingTypeUnknown; size_t len = strlen(type); if (len == 0) return YYEncodingTypeUnknown; YYEncodingType qualifier = 0; bool prefix = true; while (prefix) &#123; //方法参数Ivar中的解析，理论上解析不到该类参数 switch (*type) &#123; case 'r': &#123; qualifier |= YYEncodingTypeQualifierConst; type++; &#125; break; case 'n': &#123; qualifier |= YYEncodingTypeQualifierIn; type++; &#125; break; case 'N': &#123; qualifier |= YYEncodingTypeQualifierInout; type++; &#125; break; case 'o': &#123; qualifier |= YYEncodingTypeQualifierOut; type++; &#125; break; case 'O': &#123; qualifier |= YYEncodingTypeQualifierBycopy; type++; &#125; break; case 'R': &#123; qualifier |= YYEncodingTypeQualifierByref; type++; &#125; break; case 'V': &#123; qualifier |= YYEncodingTypeQualifierOneway; type++; &#125; break; default: &#123; prefix = false; &#125; break; &#125; &#125; len = strlen(type); if (len == 0) return YYEncodingTypeUnknown | qualifier; //返回值类型解析 switch (*type) &#123; case 'v': return YYEncodingTypeVoid | qualifier; case 'B': return YYEncodingTypeBool | qualifier; case 'c': return YYEncodingTypeInt8 | qualifier; case 'C': return YYEncodingTypeUInt8 | qualifier; case 's': return YYEncodingTypeInt16 | qualifier; case 'S': return YYEncodingTypeUInt16 | qualifier; case 'i': return YYEncodingTypeInt32 | qualifier; case 'I': return YYEncodingTypeUInt32 | qualifier; case 'l': return YYEncodingTypeInt32 | qualifier; case 'L': return YYEncodingTypeUInt32 | qualifier; case 'q': return YYEncodingTypeInt64 | qualifier; case 'Q': return YYEncodingTypeUInt64 | qualifier; case 'f': return YYEncodingTypeFloat | qualifier; case 'd': return YYEncodingTypeDouble | qualifier; case 'D': return YYEncodingTypeLongDouble | qualifier; case '#': return YYEncodingTypeClass | qualifier; case ':': return YYEncodingTypeSEL | qualifier; case '*': return YYEncodingTypeCString | qualifier; case '^': return YYEncodingTypePointer | qualifier; case '[': return YYEncodingTypeCArray | qualifier; case '(': return YYEncodingTypeUnion | qualifier; case '&#123;': return YYEncodingTypeStruct | qualifier; case '@': &#123; if (len == 2 &amp;&amp; *(type + 1) == '?') return YYEncodingTypeBlock | qualifier; //OC Block else return YYEncodingTypeObject | qualifier; //OC对象 &#125; default: return YYEncodingTypeUnknown | qualifier; &#125;&#125; 该函数也是通过获得的type encode的string，对照着表进行解析，因为是解析Ivar,所以也只包含了YYEncodingTypeMask和YYEncodingTypeQualifierMask。而YYEncodingTypePropertyMask会包含在property的解析中。 2. @interface YYClassIvarInfo : NSObject相关知识: Objective-C运行时定义了几种重要的类型。Class：定义Objective-C类Ivar：定义对象的实例变量，包括类型和名字。Protocol：定义正式协议。objc_property_t：定义属性。叫这个名字可能是为了防止和Objective-C 1.0中的用户类型冲突，那时候还没有属性。Method：定义对象方法或类方法。这个类型提供了方法的名字（就是选择器）、参数数量和类型，以及返回值（这些信息合起来称为方法的签名），还有一个指向代码的函数指针（也就是方法的实现）。SEL：定义选择器。选择器是方法名的唯一标识符。IMP：定义方法实现。这只是一个指向某个函数的指针，该函数接受一个对象、一个选择器和一个可变长参数列表（varargs），返回一个对象 @property = ivar + getter + setter; Ivar : An opaque type that represents an instance variable(实例变量，跟某个对象关联，不能被静态方法使用，与之想对应的是class variable). 1234567891011121314151617181920212223typedef struct ivar_t *Ivar;struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; 代码YYClassIvarInfo 123456789101112131415161718/** Instance variable information. */@interface YYClassIvarInfo : NSObject@property (nonatomic, assign, readonly) Ivar ivar; ///&lt; ivar opaque struct ivar本身指针@property (nonatomic, strong, readonly) NSString *name; ///&lt; Ivar's name ivar名@property (nonatomic, assign, readonly) ptrdiff_t offset; ///&lt; Ivar's offset ivar偏移量@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; Ivar's type encoding ivar encode string@property (nonatomic, assign, readonly) YYEncodingType type; ///&lt; Ivar's type ivar encode解析值/** Creates and returns an ivar info object. @param ivar ivar opaque struct @return A new object, or nil if an error occurs. */- (instancetype)initWithIvar:(Ivar)ivar;@end YYClassIvarInfo 12345678910111213141516- (instancetype)initWithIvar:(Ivar)ivar &#123; if (!ivar) return nil; self = [super init]; _ivar = ivar; const char *name = ivar_getName(ivar); //获取ivar名 if (name) &#123; _name = [NSString stringWithUTF8String:name]; &#125; _offset = ivar_getOffset(ivar); //获取偏移量 const char *typeEncoding = ivar_getTypeEncoding(ivar); //获取类型encode string if (typeEncoding) &#123; _typeEncoding = [NSString stringWithUTF8String:typeEncoding]; _type = YYEncodingGetType(typeEncoding); //类型解析 &#125; return self;&#125; YYClassIvarInfo本身就是对系统Ivar的一层封装，并进行了一次类型的解析。 PS:(阅读注:)Runtime 获取本Class中的所有属性(Ivar),并初始化一个 YYClassIvarInfo储存 实例:1234567@interface YYTestNestRepo : NSObject@property uint64_t repoID;@property NSString *name;@property YYTestNestUser *user;@end@implementation YYTestNestRepo@end YYTestNestRepo调用： 12NSString *json = @\"&#123;\\\"repoID\\\":1234,\\\"name\\\":\\\"YYModel\\\",\\\"user\\\":&#123;\\\"uid\\\":5678,\\\"name\\\":\\\"ibireme\\\"&#125;&#125;\";YYTestNestRepo *repo = [YYTestNestRepo yy_modelWithJSON:json]; 设置解析断点在解析@property YYTestNestUser *user的Ivar变量处： 3. @interface YYClassMethodInfo : NSObjectMethod:An opaque type that represents a method in a class definition. 12345678910111213141516typedef struct method_t *Method;struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 其中包含两个结构体SEL和IMP： SEL:An opaque type that represents a method selector Method selectors are used to represent the name of a method at runtime. A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 1typedef struct objc_selector *SEL; IMP:A pointer to the function of a method implementation This data type is a pointer to the start of the function that implements the method. This function uses standard C calling conventions as implemented for the current CPU architecture. The first argument is a pointer to self (that is, the memory for the particular instance of this class, or, for a class method, a pointer to the metaclass). The second argument is the method selector. The method arguments follow. 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif PS:(阅读注:)SEL 方法名字选择器，只是一个String不包括实现, IMP指的是实现，函数指针 代码YYClassMethodInfo类声明： 1234567891011@interface YYClassMethodInfo : NSObject@property (nonatomic, assign, readonly) Method method; ///&lt; method opaque struct method指针@property (nonatomic, strong, readonly) NSString *name; ///&lt; method name method名@property (nonatomic, assign, readonly) SEL sel; ///&lt; method's selector method selector@property (nonatomic, assign, readonly) IMP imp; ///&lt; method's implementation method implementation@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; method's parameter and return types method的参数和返回类型@property (nonatomic, strong, readonly) NSString *returnTypeEncoding; ///&lt; return value's type method返回值的encode types@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *argumentTypeEncodings; ///&lt; array of arguments' type method参数列表- (instancetype)initWithMethod:(Method)method;@end initWithMethod方法实现： 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithMethod:(Method)method &#123; if (!method) return nil; self = [super init]; _method = method; _sel = method_getName(method); //获取方法名，在oc中，方法名就是selector的标志 _imp = method_getImplementation(method); //获取方法实现 const char *name = sel_getName(_sel); if (name) &#123; _name = [NSString stringWithUTF8String:name]; &#125; const char *typeEncoding = method_getTypeEncoding(method); //获得方法参数和返回值 if (typeEncoding) &#123; _typeEncoding = [NSString stringWithUTF8String:typeEncoding]; &#125; char *returnType = method_copyReturnType(method); //获得返回值encode string if (returnType) &#123; _returnTypeEncoding = [NSString stringWithUTF8String:returnType]; free(returnType); &#125; unsigned int argumentCount = method_getNumberOfArguments(method); //获得方法参数数量 if (argumentCount &gt; 0) &#123; NSMutableArray *argumentTypes = [NSMutableArray new]; for (unsigned int i = 0; i &lt; argumentCount; i++) &#123; //遍历参数 char *argumentType = method_copyArgumentType(method, i); //获得该参数的encode string NSString *type = argumentType ? [NSString stringWithUTF8String:argumentType] : nil; [argumentTypes addObject:type ? type : @\"\"]; if (argumentType) free(argumentType); &#125; _argumentTypeEncodings = argumentTypes; &#125; return self;&#125; 实例1234567@interface YYTestNestRepo : NSObject@property uint64_t repoID;@property NSString *name;@property YYTestNestUser *user;@end@implementation YYTestNestRepo@end YYTestNestRepo调用： 12NSString *json = @\"&#123;\\\"repoID\\\":1234,\\\"name\\\":\\\"YYModel\\\",\\\"user\\\":&#123;\\\"uid\\\":5678,\\\"name\\\":\\\"ibireme\\\"&#125;&#125;\";YYTestNestRepo *repo = [YYTestNestRepo yy_modelWithJSON:json]; 设置解析断点解析user方法： 对于property来说，本质是:Ivar+getter+setter，所以设置了property也会触发initWithMethod解析-(YYTestNestUser *) user 方法. 引申:user没有参数，怎么method_getNumberOfArguments解析出来2个参数?原因就是方法调用最后都会转成((void (*)(id, SEL))objc_msgSend)((id)m, @selector(user));，所以会有两个参数。 @interface YYClassPropertyInfo : NSObject Property:An opaque type that represents an Objective-C declared property. 123456typedef struct property_t *objc_property_t;struct property_t &#123; const char *name; const char *attributes;&#125;; 其中对于attributes就是property属性的encode string。对应上表中属性的标识 代码YYClassPropertyInfo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@interface YYClassPropertyInfo : NSObject@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property's opaque struct property指针@property (nonatomic, strong, readonly) NSString *name; ///&lt; property's name property名@property (nonatomic, assign, readonly) YYEncodingType type; ///&lt; property's type property encode解析值@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; property's encoding value property encode string@property (nonatomic, strong, readonly) NSString *ivarName; ///&lt; property's ivar name property对应的ivar名字@property (nullable, nonatomic, assign, readonly) Class cls; ///&lt; may be nil property如果是oc类型，oc类型对应的class@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil property如果存在protocol，protocol列表@property (nonatomic, assign, readonly) SEL getter; ///&lt; getter (nonnull) property的getter方法@property (nonatomic, assign, readonly) SEL setter; ///&lt; setter (nonnull) property的setter方法- (instancetype)initWithProperty:(objc_property_t)property;@endinitWithProperty方法实现：- (instancetype)initWithProperty:(objc_property_t)property &#123; if (!property) return nil; self = [super init]; _property = property; const char *name = property_getName(property); //获得property名 if (name) &#123; _name = [NSString stringWithUTF8String:name]; &#125; YYEncodingType type = 0; unsigned int attrCount; objc_property_attribute_t *attrs = property_copyAttributeList(property, &amp;attrCount); //获得所有property的attribute array for (unsigned int i = 0; i &lt; attrCount; i++) &#123; switch (attrs[i].name[0]) &#123; case 'T': &#123; // Type encoding 表示是property类型 if (attrs[i].value) &#123; _typeEncoding = [NSString stringWithUTF8String:attrs[i].value]; //获得attribute的encode string type = YYEncodingGetType(attrs[i].value); //解析type if ((type &amp; YYEncodingTypeMask) == YYEncodingTypeObject &amp;&amp; _typeEncoding.length) &#123; //代表是OC类型 NSScanner *scanner = [NSScanner scannerWithString:_typeEncoding]; //扫描attribute的encode string if (![scanner scanString:@\"@\\\"\" intoString:NULL]) continue; //不包含@\\\"代表不是oc类型，跳过 NSString *clsName = nil; if ([scanner scanUpToCharactersFromSet: [NSCharacterSet characterSetWithCharactersInString:@\"\\\"&lt;\"] intoString:&amp;clsName]) &#123; //扫描oc类型string，在 \\\"之前 if (clsName.length) _cls = objc_getClass(clsName.UTF8String); //获得oc对象类型，并附值 &#125; NSMutableArray *protocols = nil; while ([scanner scanString:@\"&lt;\" intoString:NULL]) &#123; //扫描&lt;&gt;中的protocol类型，并设置 NSString* protocol = nil; if ([scanner scanUpToString:@\"&gt;\" intoString: &amp;protocol]) &#123; if (protocol.length) &#123; if (!protocols) protocols = [NSMutableArray new]; [protocols addObject:protocol]; &#125; &#125; [scanner scanString:@\"&gt;\" intoString:NULL]; &#125; _protocols = protocols; &#125; &#125; &#125; break; case 'V': &#123; // Instance variable //ivar变量 if (attrs[i].value) &#123; _ivarName = [NSString stringWithUTF8String:attrs[i].value]; &#125; &#125; break; case 'R': &#123; //以下为property的几种类型扫描,setter和getter方法要记录方法名 type |= YYEncodingTypePropertyReadonly; &#125; break; case 'C': &#123; type |= YYEncodingTypePropertyCopy; &#125; break; case '&amp;': &#123; type |= YYEncodingTypePropertyRetain; &#125; break; case 'N': &#123; type |= YYEncodingTypePropertyNonatomic; &#125; break; case 'D': &#123; type |= YYEncodingTypePropertyDynamic; &#125; break; case 'W': &#123; type |= YYEncodingTypePropertyWeak; &#125; break; case 'G': &#123; type |= YYEncodingTypePropertyCustomGetter; if (attrs[i].value) &#123; _getter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]); &#125; &#125; break; case 'S': &#123; type |= YYEncodingTypePropertyCustomSetter; if (attrs[i].value) &#123; _setter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]); &#125; &#125; // break; commented for code coverage in next line default: break; &#125; &#125; if (attrs) &#123; //有attrs要free free(attrs); attrs = NULL; &#125; _type = type; //最后设置encode解析值 if (_name.length) &#123; //设置默认的getter方法和setter方法 if (!_getter) &#123; _getter = NSSelectorFromString(_name); &#125; if (!_setter) &#123; _setter = NSSelectorFromString([NSString stringWithFormat:@\"set%@%@:\", [_name substringToIndex:1].uppercaseString, [_name substringFromIndex:1]]); &#125; &#125; return self;&#125; 实例1234567@interface YYTestNestRepo : NSObject@property uint64_t repoID;@property NSString *name;@property YYTestNestUser *user;@end@implementation YYTestNestRepo@end YYTestNestRepo调用 12NSString *json = @\"&#123;\\\"repoID\\\":1234,\\\"name\\\":\\\"YYModel\\\",\\\"user\\\":&#123;\\\"uid\\\":5678,\\\"name\\\":\\\"ibireme\\\"&#125;&#125;\";YYTestNestRepo *repo = [YYTestNestRepo yy_modelWithJSON:json]; 设置解析断点解析property-user： @interface YYClassInfo : NSObject Class:An opaque type that represents an Objective-C class. 123456789101112131415161718192021222324252627typedef struct objc_class *Class;struct objc_class : objc_object &#123; Class superclass; const char *name; uint32_t version; uint32_t info; uint32_t instance_size; struct old_ivar_list *ivars; struct old_method_list **methodLists; Cache cache; struct old_protocol_list *protocols; // CLS_EXT only const uint8_t *ivar_layout; struct old_class_ext *ext; ...&#125;struct objc_object &#123;private: isa_t isa;public: ...&#125; 重新引用上面文章一张图加深记忆: 上图实线是 super_class 指针，虚线是isa指针。 根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。 代码YYClassInfo： 123456789101112131415161718@interface YYClassInfo : NSObject@property (nonatomic, assign, readonly) Class cls; ///&lt; class object class指针@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object superClass指针@property (nullable, nonatomic, assign, readonly) Class metaCls; ///&lt; class's meta class object metaClass指针@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class 是否该class是metaclass@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name class名@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class's class info superClass的classinfo（缓存）@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars ivar的dictionary,key为ivar的name@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods method的dictionary,key为method的name@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties properties的dictionary,key为property的name//设置class更新，比如动态增加了一个方法，需要更新class- (void)setNeedUpdate;//返回class是否需要更新，更新则应该调用下面两个方法之一- (BOOL)needUpdate;+ (nullable instancetype)classInfoWithClass:(Class)cls;+ (nullable instancetype)classInfoWithClassName:(NSString *)className;@end YYClassInfo中有一个needUpdate是否更新的标识符，当手动更改class结构(比如class_addMethod()等)的时候，可以调用方法： 1234567891011@implementation YYClassInfo &#123; BOOL _needUpdate; //是否需要更新private变量&#125;- (void)setNeedUpdate &#123; //设置需要更新 _needUpdate = YES;&#125;- (BOOL)needUpdate &#123; //返回是否需要更新 return _needUpdate;&#125; 12345678910111213141516171819202122232425262728293031323334//多一层class从nsstring到class对象的转换+ (instancetype)classInfoWithClassName:(NSString *)className &#123; Class cls = NSClassFromString(className); return [self classInfoWithClass:cls];&#125;//class解析主体方法+ (instancetype)classInfoWithClass:(Class)cls &#123; if (!cls) return nil; static CFMutableDictionaryRef classCache; //class缓存 static CFMutableDictionaryRef metaCache; //meta class缓存 static dispatch_once_t onceToken; static dispatch_semaphore_t lock; //锁 dispatch_once(&amp;onceToken, ^&#123; //初始化两种缓存 classCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); metaCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); //只允许同时1个线程 YYClassInfo *info = CFDictionaryGetValue(class_isMetaClass(cls) ? metaCache : classCache, (__bridge const void *)(cls)); //获取曾经解析过的缓存 if (info &amp;&amp; info-&gt;_needUpdate) &#123; //如果存在且需要更新，则重新解析class并更新结构体 [info _update]; &#125; dispatch_semaphore_signal(lock); //释放锁 if (!info) &#123; //如果没有缓存，则第一次解析class info = [[YYClassInfo alloc] initWithClass:cls]; if (info) &#123; //解析完毕设置缓存 dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(info.isMeta ? metaCache : classCache, (__bridge const void *)(cls), (__bridge const void *)(info)); dispatch_semaphore_signal(lock); &#125; &#125; return info;&#125; classInfoWithClass方法中主要调用了两个方法- (instancetype)initWithClass:(Class)cls（初始化class）和 - (void)_update（更新class），接下来看该两个方法的实现。 1234567891011121314151617//初始化class对象方法- (instancetype)initWithClass:(Class)cls &#123; if (!cls) return nil; self = [super init]; _cls = cls; _superCls = class_getSuperclass(cls); //设置superclass _isMeta = class_isMetaClass(cls); //判断是否是metaclass if (!_isMeta) &#123; //不是的话获得meta class _metaCls = objc_getMetaClass(class_getName(cls)); &#125; _name = NSStringFromClass(cls); //获得类名 [self _update]; //进行更新 _superClassInfo = [self.class classInfoWithClass:_superCls]; //递归superclass return self;&#125; 也用到了- (void)_update（更新class），这应该就是class的核心更新方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//更新函数- (void)_update &#123; _ivarInfos = nil; //重置ivar，mthod，property3个缓存dictionary _methodInfos = nil; _propertyInfos = nil; Class cls = self.cls; unsigned int methodCount = 0; Method *methods = class_copyMethodList(cls, &amp;methodCount); if (methods) &#123; //解析method，并以name为key，进行缓存设置 NSMutableDictionary *methodInfos = [NSMutableDictionary new]; _methodInfos = methodInfos; for (unsigned int i = 0; i &lt; methodCount; i++) &#123; YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]]; if (info.name) methodInfos[info.name] = info; &#125; free(methods); &#125; unsigned int propertyCount = 0; objc_property_t *properties = class_copyPropertyList(cls, &amp;propertyCount); if (properties) &#123; //解析property，并以name为key，进行缓存设置 NSMutableDictionary *propertyInfos = [NSMutableDictionary new]; _propertyInfos = propertyInfos; for (unsigned int i = 0; i &lt; propertyCount; i++) &#123; YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]]; if (info.name) propertyInfos[info.name] = info; &#125; free(properties); &#125; unsigned int ivarCount = 0; Ivar *ivars = class_copyIvarList(cls, &amp;ivarCount); if (ivars) &#123; //解析ivar，并以name为key，进行缓存设置 NSMutableDictionary *ivarInfos = [NSMutableDictionary new]; _ivarInfos = ivarInfos; for (unsigned int i = 0; i &lt; ivarCount; i++) &#123; YYClassIvarInfo *info = [[YYClassIvarInfo alloc] initWithIvar:ivars[i]]; if (info.name) ivarInfos[info.name] = info; &#125; free(ivars); &#125; if (!_ivarInfos) _ivarInfos = @&#123;&#125;; //如果不存在相应的方法，则初始化空的dictionary给相应的方法 if (!_methodInfos) _methodInfos = @&#123;&#125;; if (!_propertyInfos) _propertyInfos = @&#123;&#125;; _needUpdate = NO; //已经更新完成，设no&#125; PS:(阅读注:)此方法，将method,property,ivar全部取出并附值给缓存。解析Model的Class所有属性，在 update方法中获取，获取 Class 的 Ivar , Property ,Method , 并用 YYClass 封装多一层使用. 方法中, [[YYClassInfo alloc] initWithClass:cls] , 可获取此 Class 的父类，继续做相同步骤的操作，递归感觉. 实例1234567@interface YYTestNestRepo : NSObject@property uint64_t repoID;@property NSString *name;@property YYTestNestUser *user;@end@implementation YYTestNestRepo@end YYTestNestRepo调用： 12NSString *json = @\"&#123;\\\"repoID\\\":1234,\\\"name\\\":\\\"YYModel\\\",\\\"user\\\":&#123;\\\"uid\\\":5678,\\\"name\\\":\\\"ibireme\\\"&#125;&#125;\";YYTestNestRepo *repo = [YYTestNestRepo yy_modelWithJSON:json]; 设置解析断点解析class YYTestNestRepo： 至此，整个model的class信息全部被解析完成，然后设置到了YYClassInfo类型的上。 PS(阅读注): 解析并缓存了 Class 所有属性与方法，并能动态更新 引申: class_copyPropertyList与class_copyIvarList区别 class_copyPropertyList 返回的仅仅是对象类的属性(@property申明的属性)，而 class_copyIvarList 返回类的所有属性和变量(包括在@interface大括号中声明的变量)，下面做个简单的测试。首先，定义一个WFrequencyManager类 然后在测试类中写一个测试函数testProperties调用上述两个函数得到其返回结果再分别依次遍历输出其返回值 执行上述测试函数后在控制台输出结果为： 从上述执行结果可以很好的说明前者只获取由@property声明的属性，而后者不但获取了@property属性，而且还获取了@interface大括号中声明的变量 总结:解析服务器返回JSON时候，会先使用Runtime 读取 Class 所有属性，方法，并做缓存处理 . YYModel 会判断是否有本地的不同class的映射，服务器返回不同数据则解析不同 Model的 Class . 然后，根据 KeyMapper读取每个 Class 中字典键值映射, 根据 . 符号拆分, 如下: + (NSDictionary *)modelCustomPropertyMapper { return @{ @\"name\" : @\"n\", @\"count\" : @\"ext.c\", @\"desc1\" : @\"ext.d\", // mapped to same key path @\"desc2\" : @\"ext.d\", // mapped to same key path @\"desc3\" : @\"ext.d.e\", @\"desc4\" : @\".ext\", @\"modelID\" : @[@\"ID\", @\"Id\", @\"id\", @\"ext.id\"]}; } 拆分后，根据缓存的 YYClassInfo中的键值一一赋值，完成解析 Reference: YYModel源代码分析 iOS class深入理解： 实例对象、类对象、元类和isa指针 class_copyPropertyList与class_copyIvarList区别","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"Hello World","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://swlfigo.github.io/tags/Hexo/"}]},{"title":"iOS7 以上监听音量键Tips","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/iOS7SoundsTips/","text":"iOS7 以上监听音量键TipsiOS7已经废弃 MPMusicPlayerController 这个类与方法 (还是能使用,但对于以后代码迭代，最好替换掉 ) , 如果需要控制系统音量，需要使用 MPVolumeView 以下是一些使用监听音量变化的Tips 需求：音量键拍照 &amp;&amp; 拍照无声黑科技 12//代码来看，MPVolumeView 是一个 UIView 的子类@interface MPVolumeView : UIView &lt;NSCoding&gt; 设计思路: 镜头模块需要监测音量键，音量变化触发拍照功能，为此可以设置一个单例来监测 1234567891011121314151617181920212223242526272829303132//标准单例初始化+(MPVolumeObserver*) sharedInstance;&#123; static MPVolumeObserver *instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[MPVolumeObserver alloc] init]; &#125;); return instance;&#125;-(id)init&#123; self = [super init]; if( self )&#123;/*1.初始化一个MPVolumeView来接受系统音量调整的View(平时系统按音量键弹出来的东西)2.将其添加到windows最上方(不能不添加...)PS:其实view的大小与位置并不影响*/ CGRect frame = CGRectMake(0, -100, 0, 0); _volumeView = [[MPVolumeView alloc] initWithFrame:frame]; [[UIApplication sharedApplication].windows[0] addSubview:_volumeView]; isFirstInit = NO; &#125; return self;&#125; 开始监测音量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115-(void) startObserve;&#123; /*坑点1: 移植项目时候，因为旧版里面，会使用Microphone录音，用音量键拍照时候不会弹系统音量弹框，但是新需求是用Mic的时候才用激活Microphone Audiosession负责调节你的app和ios系统里的音频行为.一旦加载了audiosession你可以获得一个Audiosession的单例.你可以配置这个Audiosession来控制你的app的音频行为.例如:当你的app播放声音的时候,你是希望其他正在播放声音的app静音还是混合两个app的声音?你的app如何回应突发的打断,例如这时候闹铃突然响了?你的app又该如何回应耳机口的拔插呢?AuioSession的配置会影响你的app在运行中所有的音频活动,除了利用System Sounds Services API控制的音频.你还可以利用AudioSession来检测你所用硬件的参数,例如声道和采样率.你还可以随时激活或者停止你的audioSession,当你的app播放声音或者正在录音的时候,你必须确保AudioSession处于激活状态.系统也有权利随时中断你的audioSession,例如,当你来电话的时候.当然,AudioSession提供了api来让你的app从这种中断中恢复. 如果不初始化 AVAudioSession .则用音量键调节时候，会弹系统音量框！！！！！！！！切记！（原来没有弹是因为调用了Mic，Mic可能自带AVAudioSession的创建）*/ //iOS7 以下用这个 // AudioSessionInitialize(NULL, NULL, NULL, NULL);// SInt32 process = kAudioSessionCategory_AmbientSound;// AudioSessionSetProperty(kAudioSessionProperty_AudioCategory, sizeof(process), &amp;process);// AudioSessionSetActive(YES); //iOS7以上 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:nil]; [[AVAudioSession sharedInstance] setActive:YES error:nil]; /*遍历MPVolumeView,获得其中的Slider,Slider就是当前系统音量 */ [[_volumeView subviews]enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj isKindOfClass:[UISlider class]]) &#123; //需要send一下才不会获取0/*坑点2: 如果不设置这段代码，则获得出来的音量是0，多次测试后发现，如果之前已经调整过音量，则可以正常获得音量，猜测:需要调整过系统的才可以初始化Slider，才获得正确音量 这个方法模拟点击事件，则达到上面的要求*/ [((UISlider*)obj) sendActionsForControlEvents:UIControlEventTouchUpInside]; //获得Slider音量大小 launchVolume = ((UISlider*)obj).value; *stop = YES; &#125; &#125;]; //iOS7以下设置音量和获取音量方法// launchVolume = [[MPMusicPlayerController applicationMusicPlayer] volume];//不给调到0声音 launchVolume = launchVolume == 0 ? 0.05 : launchVolume; launchVolume = launchVolume == 1 ? 0.95 : launchVolume; if (launchVolume == 0.05 || launchVolume == 0.95) &#123;// [[MPMusicPlayerController applicationMusicPlayer] setVolume:launchVolume]; //New. [[_volumeView subviews]enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj isKindOfClass:[UISlider class]]) &#123; //需要send一下才不会获取0// [((UISlider*)obj) sendActionsForControlEvents:UIControlEventTouchUpInside]; //获得Slider音量大小 ((UISlider*)obj).value = launchVolume; *stop = YES; &#125; &#125;]; &#125; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(suspendObserveVolumeChangeEvents:) name:UIApplicationWillResignActiveNotification // -&gt; Inactive object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(resumeObserveVolumeButtonEvents:) name:UIApplicationDidBecomeActiveNotification // &lt;- Active object:nil]; //AVSystemController_SystemVolumeDidChangeNotification //SystemVolumeDidChange //监听系统音量 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChangeNotification:) name:@\"SystemVolumeDidChange\" object:nil];&#125; 以上方法能检测出系统音量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-(void) volumeChangeNotification:(NSNotification *) no&#123; NSLog(@\"Volume Change!!\"); static id sender = nil; if (sender == nil &amp;&amp; no.object) &#123; sender = no.object; &#125; if (no.object != sender || [[no.userInfo objectForKey:@\"AudioVolume\"] floatValue] == launchVolume) &#123; return; &#125; /*坑点3： 返回的通知字典里面,有一个key记录着系统音量通知变化的原因，只有 ExplicitVolumeChange 才代表音量变化,插拔耳机都会触发音量变化通知的！！！*/ //如果检测出抽插耳机，则不需要音量监控 if (![[no.userInfo objectForKey:@\"AudioVolumeChangeReason\"] isEqualToString:@\"ExplicitVolumeChange\"]) &#123; return; &#125; // [[MPMusicPlayerController applicationMusicPlayer] setVolume:launchVolume];/*坑点4： 不能通过_volumeView 重新设置会音量，因为按了，声音会变大一点在变回原来的音量，但是并不满足需求 通过研究,只能通过新建一个MPVolumeView，来设置，则不会有音量变化*/ //New. MPVolumeView *volumeView= [[MPVolumeView alloc] initWithFrame:CGRectMake(-2000.0f, -2000.0f, 0.0f, 0.0f)]; volumeView.alpha = 0.10f; volumeView.userInteractionEnabled = NO; NSArray *windows = [UIApplication sharedApplication].windows; [[windows firstObject] addSubview:volumeView]; [[volumeView subviews]enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj isKindOfClass:[UISlider class]]) &#123; //第一次获取到的launchVolume为0，按音量键拍照的时候设置为0，会导致拍照后的音量为0 ((UISlider*)obj).value = launchVolume; *stop = YES; &#125; &#125;]; [volumeView removeFromSuperview]; if ([self.delegate respondsToSelector:@selector(volumeButtonDidClick:)] ) &#123; [self.delegate volumeButtonDidClick:self]; &#125; &#125; 当然需要stop监察 1234567891011-(void)stopObserveVolumeChangeEvents&#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; // AudioSessionRemovePropertyListenerWithUserData(kAudioSessionProperty_CurrentHardwareOutputVolume, NULL, (__bridge void *)(self));// AudioSessionSetActive(NO); &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"iOS马赛克图片画笔一种实现思路","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/iOSMosaiImagePen/","text":"iOS马赛克图片画笔一种实现思路先看下效果: 功能: 能实现马赛克画笔功能,并提供多种马赛克图案层叠测试 实现了重做，撤销功能 实现了对原图做处理功能，并不是失真保存图案 优化了处理时 CPU 占用太高问题 从DrawRect说起在我们平时开发中,难免会遇到画笔，画线问题。第一个想到的是使用 drawRect 方法实现功能。 但是drawRect方法会存在较大的内存问题。 举个栗子:我们需要实现一个画板功能,我们会这样做: 新建一个画布 在 touchBegan方法 或者 添加手势方法中 , 保存获得的路径点 , 生成路径 调用 [setNeedDisplay] , 在 -(void)drawRect 方法里面, 绘制出来. 在大量操作之后，内存、CPU 就会出现明显问题。 那么为什么会有这个问题呢? DrawRect调用场景 drawRect方法在UIView的使用上起着十分关键的作用。视图第一次显示的时候会调用。这个是由系统自动调用的，主要是在 UIViewController中loadView和viewDidLoad方法调用之后； 如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用； 该方法在调用sizeThatFits后被调用,所以可以先调用sizeToFit计算出size,然后系统自动调用drawRect:方法； 通过设置contentMode属性值为UIViewContentModeRedraw,那么将在每次设置或更改frame的时候自动调用drawRect:; 直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0; DrawRect 内存问题在iOS系统中所有显示的视图都是从基类UIView继承而来的，同时UIView负责接收用户交互。但是实际上你所看到的视图内容，包括图形等，都是由UIView的一个实例图层属性来绘制和渲染的，那就是CALayer。 CALayer类的概念与UIView非常类似，它也具有树形的层级关系，并且可以包含图片文本、背景色等。它与UIView最大的不同在于它不能响应用户交互，可以说它根本就不知道响应链的存在，它的API虽然提供了“某点是否在图层范围内的方法”，但是它并不具有响应的能力。 在每一个UIView实例当中，都有一个默认的支持图层，UIView负责创建并且管理这个图层。实际上这个CALayer图层才是真正用来在屏幕上显示的，UIView仅仅是对它的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。 可以说CALayer是UIView的内部实现细节。 CALayer其实也只是iOS当中一个普通的类，它也并不能直接渲染到屏幕上，因为屏幕上你所看到的东西，其实都是一张张图片。而为什么我们能看到CALayer的内容呢，是因为CALayer内部有一个contents属性。contents默认可以传一个id类型的对象，但是只有你传CGImage的时候，它才能够正常显示在屏幕上。所以最终我们的图形渲染落点落在contents身上如图。 -drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。 contents也被称为寄宿图，除了给它赋值CGImage之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承UIView并实现-drawRect:方法即可自定义绘制。-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，UIView不关心绘制的内容。如果UIView检测到-drawRect:方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以contentsScale(这个属性与屏幕分辨率有关， 回到上面 画板 栗子中,因为重写了-drawRect:方法，-drawRect :方法就会自动调用。生成一张寄宿图后，方法里面的代码利用Core Graphics去绘制n条黑色的线，然后内容就会缓存起来，等待下次你调用-setNeedsDisplay时再进行更新。 画板视图的-drawRect:方法的背后实际上都是底层的CALayer进行了重绘和保存中间产生的图片，CALayer的delegate属性默认实现了CALayerDelegate协议，当它需要内容信息的时候会调用协议中的方法来拿。当画板视图重绘时，因为它的支持图层CALayer的代理就是画板视图本身，所以支持图层会请求画板视图给它一个寄宿图来显示，它此刻会调用： 1- (void)displayLayer:(CALayer *)layer; 如果画板视图实现了这个方法，就可以拿到layer来直接设置contents寄宿图，如果这个方法没有实现，支持图层CALayer会尝试调用： 1- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 这个方法调用之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。在这一步生成的空寄宿图内存是相当巨大的，它就是本次内存问题的关键，一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽图层高4字节，宽高的单位均为像素。 图层每次重绘的时候都需要重新抹掉内存然后重新分配。它就是我们画板程序内存暴增的真正原因。 最合理的办法处理类似于画板这样画线条的需求直接用专有图层CAShapeLayer CAShapeLayerdrawRect：属于CoreGraphics框架，占用CPU，性能消耗大，不建议重写CAShapeLayer：属于CoreAnimation框架，通过GPU来渲染图形，节省性能。动画渲染直接提交给手机GPU，不消耗内存这两者各有各的用途，而不是说有了CAShapeLayer就不需要drawRect。 drawRect只是一个方法而已，是UIView的方法，重写此方法可以完成我们的绘制图形功能。 CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。用CGPath来定义想要绘制的图形，CAShapeLayer会自动渲染。它可以完美替代我们的直接使用Core Graphics绘制layer，对比之下使用CAShapeLayer有以下优点： 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉。 不会出现像素化。 CAShapeLayer 与 Mask我们知道，如果你想要显示一个图层的内容，需要将其加到图层的层级上 1- [CALayer addSublayer:] 当你需要将一个CALayer的内容变成圆角的时候，你可以通过设置cornerRadius来很方便的实现，但是如果你想要一个CALayer的内容被剪裁成任意形状应该如何是好呢？ 如果你使用过Photoshop，这个问题你肯定知道可以创建一个图层蒙版来实现。而在CoreAnimation中，框架同样为我们提供了这样的功能，CALayer拥有一个属性叫做mask，作为这个CALayer对象的蒙版，mask本身也是一个CALayer，比如： 123CALayer * layer = [CALayer layer];CALayer * maskLayer = [CALayer layer];layer.mask = maskLayer; 这样的话，maskLayer就成为了layer的蒙版，maskLayer类似于一个子图层，相对于父图层（即拥有该属性的图层，在这里就是layer）布局，但是它却不是一个普通的子图层。maskLayer并不会直接绘制在父图层之上，它只是定义了父图层的“可视部分”。 想象maskLayer是一张纸，盖在了layer上，那么layer能显示出来的内容，就是maskLayer“不是透明的部分”的内容。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的（透明的部分）则会被抛弃。 马赛克画笔思路总结了上面 -drawRect 的不足与 CAShapeLayer 的优点，马赛克画笔思路也有了，选在再实时显示时候，使用 CAShapeLayer 与 mask 蒙版的结合，达到马赛克画笔功能，再每一笔画完时候，使用 -drawRect 生成一张原图片大小的画布，在上面抠出马赛克画笔的路径，然后将马赛克图案与原图融合，达到马赛克效果。 Q:为什么要生成原图? 因为当前实时显示的马赛克效果，是原图按比例缩小到屏幕尺寸显示出来的，实际上，如果需要对原图处理，需要将移动路径点重新乘上缩小的比例，那么实时显示的点才是对应原图上的点 生成的图，并不是通过layer渲染的失真缩小图 重点: 当选择 A 马赛克图案作为画笔纹理时候，其实就是将马赛克图案作为一个 layer 寄宿图加载出来，通过mask蒙版遮住路径以外的位置，那么看到的是，路径所显示马赛克底图的路径了。每次画笔画完，都会保存一张每一笔处理完马赛克与原图的融合图，下次替换马赛克图案时候，如上面初始化方法，将上一笔生层融合图作为原图，新马赛克图案再作为layer，绘制新的马赛克。 Reference: 谈谈对drawRect的理解 内存恶鬼drawRect Custom Drawing iOS CoreAnimation专题——技巧篇（三）Layer Masking - 图层蒙版","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"高性能iOS应用开发","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/iOSPerformanceReadNote/","text":"最近读《高性能iOS应用开发》一书，重新了解了下iOS中内存模型与一些开发中注意事项，并摘抄书中知识点做了下笔记，另外原来不了解方面知识也做了相关资料搜索作笔记补充。（如有错误欢迎指正） 一. 开始1. 移动应用的性能1.1 定义性能性能是非常模糊的术语,高性能有着多重的含义和丰富的解释方式。（需要测量和监控的）性能指标是其中的 一个关注点，（实际上收集数据的）测量是另一个关注点。 1.2 性能指标性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。同时还要确保没有泄漏内存。随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。 1.2.2 电量消耗电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件。除了要实现电量消耗最小化，还要确保不会影响用户体验。 1.2.3 初始化时间应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。 刚好够用是一个开放式用语——正确的平衡点取 决于应用的需要。 1.2.4 执行速度一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。 1.2.5 响应速度每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。 1.2.6 本地存储针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。如果你的应用使用了本地存储，那么请提供一个清除数据的选项。 1.2.7 互操作性用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。 1.2.8 网络环境移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件： 高带宽稳定网络 低带宽稳定网络 高带宽不稳定网络 低带宽不稳定网络 无网络 1.2.9 安全安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。 二. 核心优化该部分讨论的优化包括以下方面: 内存管理 能耗 并发编程 2. 内存管理与（基于垃圾回收的）Java 运行时不同， Objective-C 和 Swift 的 iOS 运行时使用引用计数。 使用引用计数的负面影响在于，如果开发人员不够小心，那么可能会出现重复的内存释放 和循环引用的情况。 2.1 内存消耗内存消耗指的是应用消耗的RAM。 iOS 的虚拟内存模型并不包含交换内存，与桌面应用不同，这意味着磁盘不会被用来分页 内存。最终的结果是应用只能使用有限的 RAM。 这些 RAM 的使用者不仅包括在前台运行 的应用，还包括操作系统服务，甚至还包括其他应用所执行的后台任务。 应用中的内存消耗分为两部分：栈大小和堆大小。 2.1.1 栈大小应用中新创建的每个线程都有专用的栈空间， 该空间由保留的内存和初始提交的内存组成。线程的最大栈空间很小，这就决定了以下的限制。 可被递归调用的最大方法数 每个方法都有其自己的栈帧，并会消耗整体的栈空间。如果你调 用 main ，那么 main 将调用 method1 ，而 method1 又将调用 method2 ， 这就存在三个栈帧了，且每个栈帧都会消耗一定字节的内存。 1234567main() &#123; method1(); &#125;method1() &#123; method2(); &#125; 一个方法中最多可以使用的变量个数 所有的变量都会载入方法的栈帧中，并消耗一定的栈空间。 视图层级中可以嵌入的最大视图深度 渲染复合视图将在整个视图层级树中递归地调用 layoutSubViews 和 drawRect 方法。如果层级过深，可能会导致栈溢出。 2.1.2 堆大小每个进程的所有线程共享同一个堆。使用 NSString 、载入图片、创建或使用 JSON/XML 数据、使用视图等都会消耗大量的堆 内存。与通过类创建的对象相关的所有数据都存放在堆中。类可能包含属性或值类型的实例变量（iVars）， 如 int 、 char 或 struct 。但因为对象是在堆内创建的，所以它们只消耗堆内存。当对象被创建并被赋值时，数据可能会从栈复制到堆。类似地， 当值仅在方法内部使用 时，它们也可能会被从堆复制到栈。 123456789101112131415161718192021@interface AClass @property (nonatomic, assign) NSInteger anInteger; @property (nonatomic, copy) NSString *aString;@end //一些其他的类 -(AClass *) createAClassWithInteger:(NSInteger)i string:(NSString *)s &#123; AClass *result = [AClass new]; result.anInteger = i; result.aString = s;&#125;-(void) someMethod:(NSArray *)items &#123; NSInteger total = 0; NSMutableString *finalValue = [NSMutableString string]; for(AClass *obj in items) &#123; total += obj.anInteger; [finalValue appendString:obj.aString]; &#125;&#125; 如下总结: i 的值在栈上。但赋值给属性时，它必须被复制到堆中，因为那是存储 result 的地方。 虽然 NSString * 通过引用传递，但这个属性被标记为 copy 。这意味着它的值必须被复 制或克隆，这取决于 [-NSCopying copyWithZone:] 方法的实现。 使用 anInteger 时，它的值必须先复制到栈然后才能进行进一步的处理。在本示例中，它的值加到 total。 2.2 内存管理模型内存管理模型基于持有关系的概念。如果一个对象正处于被持有状态，那它占用的内存就 不能被回收。 一旦与某个对象相关的任务全部完成，那么就是放弃了持有关系。这一过程没有转移持有 关系，而是分别增加或减少了持有者的数量。当持有者的数量降为零时，对象会被释放。 这种持有关系计数通常被正式称为引用计数。 eg.1 如: 123456NSString *message = @&quot;Objective-C is a verbose yet awesome language&quot;;NSString *messageRetained = [message retain]; [messageRetained release]; [message release]; NSLog(@&quot;Value of message: %@&quot;, message); 创建对象、message 建立了持有关系，引用计数为 1。 messageRetained 建立了持有关系，引用计数增加为 2。 messageRetained 放弃了持有关系，引用计数降为 1。 message 放弃了持有关系，引用计数降为 0。 严格来讲，此时 message 的值是未定义的。你仍然能像之前那样得到相同的值，因为它 对应的内存还没有被回收或重置 eg.2 方法中的引用计数: 1234567891011121314//一个Person类的部分 //注:此 NSString 创建方法相当不科学，可能作者为了例子这样写，我会在小结处再做进一步解释-(NSString *) address &#123; NSString *result = [[NSString alloc] initWithFormat:@\"%@\\n%@\\n%@, %@\", self.line1, self.line2, self.city, self.state]; return result; &#125;-(void) showPerson:(Person *) p &#123; NSString *paddress = [p address]; NSLog(@\"Person's Address: %@\", paddress); [paddress release];&#125; 首次创建对象，result 指向内存的引用计数为 1。 通过 paddress （指向 result ）指向的内存的引用计数仍然是 1。 showPerson: 方法通过 address 按钮创建了对象，是对象的持有者。对象不应该被再次持有（ retain )。 放弃持有关系；引用计数降为 0。 2.3 自动释放对象自动释放对象让你能够放弃对一个对象的持有关系，但延后对它的销毁。当在方法中创建 一个对象并需要将其返回时，自动释放就显得非常有用。自动释放可以帮助在 MRC 中管 理对象的生命周期。 在上面例子中，没什么能表示 address 方法持有了返回的字符串。因此，方法的调用者 showPerson: 也不应该释放返回的字符串，这可能会导致发生内存泄漏。加入 [paddress release] 这行代码的目的是为了指明这种情况。 以下是两种可能的解决方案。 不要使用 alloc 或相关的方法。 对返回的对象使用延时释放。 修改代码如下: eg.3 不要使用 alloc 或相关的方法 12345678910-(NSString *) address &#123; NSString *result = [NSString stringWithFormat:@&quot;%@\\n%@\\n%@, %@&quot;, self.line1, self.line2, self.city, self.state]; return result;&#125;-(void) showPerson:(Person *) p &#123; NSString *paddress = [p address]; NSLog(@&quot;Person&apos;s Address: %@&quot;, paddress);&#125; 不要使用 alloc 方法。 由于 showPerson: 方法没有创建实体对象，因此不要在 showPerson: 方法中使用 release 方法。 但是，当使用第三方类库或者某个类有多个用于创建对象的方法 时，到底是哪个方法保持了持有关系并不明确。所以引入了 autorelease eg.4 autorelease 12345-(NSString *) address &#123; NSString *result = [[[NSString alloc] initWithFormat:@&quot;%@\\n%@\\n%@, %@&quot;, self.line1, self.line2, self.city, self.state] autorelease]; return result; &#125; 持有的对象（在上述示例中是 NSString ）是 alloc 方法返回的。 确保没有内存泄漏，你必须在失去引用之前放弃持有关系。 但是，如果使用了 release ,那么对象的释放将发生在返回之前，因而方法将返回一个 无效的引用。 autorelease 表明你想要放弃持有关系，同时允许方法的调用者在对象被释放之前使用对象。 结论如下: 当创建一个对象并将其从非 alloc 方法返回时，应使用 autorelease。 这样可以确保对象将被释放，并尽量在调用方法执行完成时立即释放。 2.4 自动释放池块 (@autoreleasepool)自动释放池块是允许你放弃对一个对象的持有关系、但可避免它立即被回收的一个工具。它还能确保在块内创建的对象会在块完成时被回收。本地的块可以用来尽早地释放其中的对象，从而使内存用量保持在较低的水平。 main.m 文件中的 @autoreleasepool 代码段 123456//main.mint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([HPAppDelegate class])); &#125;//end 那么，块中收到过 autorelease 消息的所有对象都会在 autoreleasepool 块结束时收到 release 消息 (注 : 根据一些网上一些文章解析, Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop ) 但在一些特定情况下，可能想创建自己的 autoreleasepool 块 当你有一个创建了很多临时对象的循环时 在循环中使用 autoreleasepool 块可以为每个迭代释放内存。虽然迭代前后最终的内存 使用相同，但你的应用的最大内存需求可以大大降低。 eg.1 错误的 autoreleasepool 示范代码 1234567891011121314151617181920 //错误代码示范&#123; @autoreleasepool &#123; NSUInteger *userCount = userDatabase.userCount; for(NSUInteger *i = 0; i &lt; userCount; i++)&#123; Person *p = [userDatabase userAtIndex:i]; NSString *fname = p.fname; if(fname == nil) &#123; fname = [self askUserForFirstName]; &#125; NSString *lname = p.lname; if(lname == nil) &#123; lname = [self askUserForLastName]; &#125; //... [userDatabase updateUser:p]; &#125; &#125;&#125; eg.2 正确 autoreleasepool 示范: 12345678910111213141516171819202122&#123; @autoreleasepool &#123; NSUInteger *userCount = userDatabase.userCount; for(NSUInteger *i = 0; i &lt; userCount; i++)&#123; @autoreleasepool &#123; Person *p = [userDatabase userAtIndex:i]; NSString *fname = p.fname; if(fname == nil) &#123; fname = [self askUserForFirstName]; &#125; NSString *lname = p.lname; if(lname == nil) &#123; lname = [self askUserForLastName]; &#125; //... [userDatabase updateUser:p]; &#125; &#125; &#125;&#125; eg1中这段代码，因为只有一个 autoreleasepool ，而且内存清理工作要在所有的循环 迭代完成之后才能进行。 这个示例中有两个 autoreleasepool ，内层的 autoreleasepool 确保在每次循环迭代完成 后清理内存，从而导致更少的内存需求。 2.5 自动引用计数持续跟踪 retain 、 release 和 autorelease 并不容易。要想找出是谁在什么时间和地点向谁 发送了这些消息就更难了。2011 年的全球开发者大会上介绍了解决这一问题的方案——ARC。ARC 是一种编译器特性。 它评估了对象在代码中的生命周期，并在编译时自动注入适合的 内存管理调用。编译器还会生成适合的 dealloc 方法。 ARC规则 不能实现或调用 retain 、 release 、 autorelease 或 retainCount 方法。 这一限制不仅针 对对象，对选择器同样有效。因此， [obj release] 或 @selector(retain) 是编译时的错误。 可以实现 dealloc 方法，但不能调用它们。不仅不能调用其他对象的 dealloc 方法，也不能调用超类。 [super dealloc] 是编译时的错误。 但你仍然可以对 Core Foundation 类型的对象调用 CFRetain 、 CFRelease 等相关方法。(注: CF 库需要手动内存管理) 不能调用 NSAllocateObject 和 NSDeallocateObject 方法。应使用alloc方法创建对象，运行时负责回收对象。 不能在 C 语言的结构体内使用对象指针。 不能在 id 类型和 void * 类型之间自动转换。如果需要，那么你必须做显示转换。 不能使用 NSAutoreleasePool ，要替换使用 autoreleasepool 块。 不能使用 NSZone 内存区域。 属性的访问器名称不能以 new 开头，以确保与 MRC 的互操作性。 2.6 引用类型ARC 带来了新的引用类型：弱引用。 强引用强引用是默认的引用类型。 被强引用指向的内存不会被释放。 强引用会对引用计数加 1， 从而扩展对象的生命周期。 弱引用弱引用是一种特殊的引用类型。它不会增加引用计数，因而不会扩展对象的生命周期。 2.6.1 变量限定符ARC 为变量供了四种生命周期限定符。 (注:由于书上内容解析不太深刻，找到个更好的解析) Variable Qualifier Desc __strong 是默认的。只要有强类型指针指向一个对象，那么该对象会一直”生存“下去。 __weak 表明一个不会维持所持对象生命期的引用。当没有强引用指向该对象时，弱引用会设置为nil。 __unsafe_unretained 指定一个引用，该引用不会维持所持对象的生命期，并且在没有强引用指向对象时也不会设置为nil。如果它所指向的对象已经被释放，那么它会成为一个野指针。 __autoreleasing 用以指示以引用（id*）传入的参数并在retun后自动释放。 eg.1 使用变量限定符 123451. Person * __strong p1 = [[Person alloc] init]; 2. Person * __weak p2 = [[Person alloc] init];3. Person * __unsafe_unretained p3 = [[Person alloc] init]; 4. Person * __autoreleasing p4 = [[Person alloc] init]; 创建对象后引用计数为 1， 并且对象在 p1 引用期间不会被回收。 创建对象后引用计数为 0， 对象会被立即释放，且 p2 将被设置为 nil 。 创建对象后引用计数为 1， 对象会被立即释放，但 p3 不会被设置为 nil 。 创建对象后引用计数为 1， 当方法返回时对象会被立即释放。 2.7 僵尸对象僵尸对象是用于捕捉内存错误的调试功能。通常情况下，当引用计数降为 0 时对象会立即被释放，但这使得调试变得困难。如果开启 了僵尸对象， 那么对象就不会立即释放内存， 而是被标记为僵尸。 任何试图对其进行访 问的行为都会被日志记录， 因而你可以在对象的生命周期中跟踪对象在代码中被使用的位置。 2.9 循环引用(注: 书上的例子非常不科学，写出来是没有循环引用问题的。循环引用开发中比较常见，所以这里不做更多笔记说明。) Final 内存这块笔记小结:读完内存模块这一章节了解到更多内存管理方面知识,有以下几点补充总结。 1. iOS中一共有哪些存储空间： 栈区（stack） 堆区（heap） 静态区 寄存器区 文字常量区 程序代码区 2. 栈区栈区中的内存空间是由编译器自动释放的，一般来是存放参数，局部变量等等。在iOS开发中，栈空间的大小为1M。 3. 堆区栈空间只有1M，那么我们很多时候需要的资源都会超过1M，所以由此也引出了堆。在iOS中，栈空间是每个程序都有一个的，而且互相不干扰，堆空间则是一个系统公共的，换句话说就是所有的应用程序都使用一个堆空间。对于堆中的内存空间的操作，是通过链表来操作的 4. (MRC) stringWithFormat 和 initWithFormat 有何不同？ initWithFormat是实例方法 只能经由过程 NSString* str = [[NSString alloc] initWithFormat:＠”％＠”，＠”Hello World”] 调用，然则必须手动release来开释内存资料 stringWithFormat是类方法 可以直接用 NSString* str = [NSString stringWithFormat:＠”％＠”，＠”Hello World”] 调用，内存经管上是autorelease的，不需手动显式release Example: 别的国外有个贴子对此有专门评论辩论并且提出了一个常见错误: 12label.text = [[NSString alloc] initWithFormat:＠&quot;％＠&quot;，＠&quot;abc&quot;]; 最后在 dealloc 中将 label给 release 掉然则仍然会产生内存泄漏！ 原因在于：用 label.text = … 时，实际是隐式调用的label的setText办法，这会retain label内部的字符串变量text（哪怕这个字符串的内容跟传进来的字符串内容雷同，但体系仍然当成二个不合的字符串对象），所以最后release label时，实际上只开释了label内部的text字符串，然则最初用initWithFormat生成的字符串并未开释，终极造成了泄漏。 为什么会导致这样的情况呢？ initWithString申请的地址每次都是一样的，而initWithFormat的地址每次都不一样，这个说明什么？说明initWithString的地址是静态的，而initWithFormat是动态的。 5. __autoreleasing有以下代码: 123456NSError *error;BOOL OK = [myObject performOperationWithError:&amp;error];if (!OK) &#123; //blablabla //...&#125; 其中，error 是隐式调用: 1NSError * __strong e; 方法的声明通常是： 1- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error; 因此编译器会重写代码： 12345678NSError * __strong error;NSError * __autoreleasing tmp = error;BOOL OK = [myObject performOperationWithError:&amp;tmp];error = tmp;if (!OK) &#123; //blablabla //...&#125; 本地变量声明( strong)和参数( autoreleasing)之间的区别导致编译器创建临时变量。在获取strong变量的地址时你可以通过将参数声明为 id storng*来获得其原始指针。或者你可以将变量声明为 __autoreleasing。 问题: -(BOOL)performOperationWithError:(NSError * __autoreleasing *)error;中为什么需要用 __autoreleasing 变量限定符修饰？ 本地变量声明( __strong)和参数( __autoreleasing)之间的区别导致编译器创建临时变量？ 解决上述两个问题，首先得知道: __autoreleasing是什么？ autoreleasing作用什么？（为什么要使用autoreleasing） 5.1 __autoreleasing 是什么？__autoreleasing 是 ARC 下用于控制变量生命周期而引入的4个变量限定符之一。 5.2 autoreleasing 作用什么？（为什么要使用autoreleasing)?ARC: 不能显式的调用dealloc，实现或调用 retain， release， retainCount，或 autorelease。 不能使用 NSAutoreleasePool 对象 ARC 提供了 @autoreleasepool来代替。这比 NSAutoreleasePool更高效。 对比一下 MRC 与 ARC 下使用 autoreleasepool 的不同地方： 12345/* MRC */1 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];2 id obj = [[NSObject alloc] init];3 [obj autorelease]; //对象调用 autorelease 方法就是将该对象注册到最近的 autoreleasepool 中4 [pool drain]; 1234/* ARC */1 @autoreleasepool &#123;2 id __autoreleasing obj = [[NSObject alloc] init];3 &#125; 通过将对象赋值给带有 __autoreleasing 修饰符的变量来代替调用 autorelease 方法，即将对象注册到 autoreleasepool 所以: 被添加到autoreleasepool了，默认情况下要将 obj 指向的对象添加到autoreleasepool中是需要 __autoreleasing 修饰符去修饰 obj 的，那么ARC 下它应该就会进行一个编译转换，如： 1id __autoreleasing tem = obj; Reference https://blog.csdn.net/nineteen_/article/details/48782465 http://www.isaced.com/post-240.html https://www.jianshu.com/p/245bdcb47e3b https://www.jianshu.com/p/0258ed2133ff 3. 能耗(注:这部分没有太多可以做笔记的知识点，忽略) 4. 并发编程4.1 线程线程是运行时执行的一组指令序列。 每个进程至少应包含一个线程。在 iOS 中，进程启动时的主要线程通常被称作主线程。所 有的 UI 元素都需要在主线程中创建和管理。 Cocoa 编程不允许其他线程更新 UI 元素。这意味着，无论何时应用在后台线程执行了耗时 操作，比如网络或其他处理，代码都必须将上下文切换到主线程再更新 UI 4.2 线程开销线程不仅仅有创建时的时间开销，还会消耗内核的内存，即应用的内存空间。 4.2.1 内核数据结构每个线程大约消耗 1KB 的内核内存空间。这块内存用于存储与线程有关的数据结构和属 性。这块内存是联动内存（wired memory） ，无法被分页。 4.2.2 栈空间主线程的栈空间大小为 1M， 而且无法修改。所有的二级线程默认分配 512KB 的栈空间。 注意，完整的栈并不会立即被创建出来。实际的栈空间大小会随着使用而增长。因此，即 使主线程有 1MB 的栈空间，某个时间点的实际栈空间很可能要小很多。 4.3 GCDGCD 提供的功能列表: 任务或分发队列，允许主线程中的执行、并行执行和串行执行。 分发组，实现对一组任务执行情况的跟踪，而与这些任务所基于的队列无关。 信号量。 屏障，允许在并行分发队列中创建同步的点。 分发对象和管理源，实现更为底层的管理和监控。 异步 I/O， 使用文件描述符或管道。 注意:当应用中有多个长耗时的任 务需要并行执行时，最好 . 对线程的创建过程加以控制。如果代码执行的时间过长，很有可能达到线程的限制 64 个， 2,3 即 GCD 的线程池上限。 4.4 操作与队列NSOperation 封装了一个任务以及和任务相关的数据和代码， 而 NSOperationQueue 以先入 先出的顺序控制了一个或多个这类任务的执行。 NSOperation 和 NSOperationQueue 都提供控制线程个数的能力。 可用 maxConcurrentOperationCount 属性控制队列的个数，也可以控制每个队列的线程个数。 NSOperationQueue 和 GCD API 快速比较。 GCD 抽象程度最高。 两种队列开箱即用： main 和 global 。 可以创建更多的队列（使用 dispatch_queue_create ） 可以请求独占访问（使用 dispatch_barrier_sync 和 dispatch_barrier_async ）。 基于线程管理。 硬性限制创建 64 个线程。 NSOperationQueue 无默认队列。 应用管理自己创建的队列。 队列是优先级队列。 操作可以有不同的优先级（使用 queuePriority 属性)。 使用 cancel 消息可以取消操作。注意， cancel 仅仅是个标记。 如果操作已经开始执行，则可能会继续执行下去。 可以等待某个操作执行完毕（使用 waitUntilFinished 消息）。 4.5 线程安全的代码书中讨论了 atomic 与 nonatomic 问题，与 @synchronized 的使用. 关于 atomic 与 nonatomic 是否绝对安全，一些面试题或者博客有更好的解释。 归纳知识点如下: 所有的属性默认都是原子性的。 atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。 对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。 而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。 不过atomic可并不能保证线程安全。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。 摘取 Mr.Peak 博客一个小结: atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。 原文: 传送门 另外文中还有一些锁的概念，这里也不做太多扩展. 三. 性能5. 应用生命周期iOS 应用启动时会调用 UIApplicationMain 方法，并传入 UIApplicationDelegate 类的引用。 委托接收应用范围的事件， 并且有明确的生命周期,application:didFinishLaunchingWit hOptions: 方法表明应用已经启动。关键组件的初始化就发生在这个方法中，如崩溃上报、 网络、日志以及埋点的初始化。此外，初次启动或恢复前置状态以便后续启动时，还可能会执行一些一次性的初始化操作。 5.1 应用委托应用委托通常是应用创建的第一个对象。它为应用提供一些环境变量，其中包括应用启动 的详细信息、远程通知、深层链接，等等。 如图启动流程: 5.2 应用启动著名的 application:didFinishLaunchingWithOptions:方法是应用启动时最核心的地方。此 处不能发生任何错误，且绝不能发生崩溃，否则应用将无法正常使用，直到下次升级。 应用有四种启动类型。 首次启动 安装应用后的首次启动。此时没有之前的状态，也没有本地缓存。 这意味着将会出现以下两种情况中的一种：没有需要加载的内容（因此加载时间会缩 短)，或者需要从服务器上下载初始数据（可能需要很长的加载时间）。 冷启动 应用后续的启动。在启动期间，可能需要恢复原来的状态，例如，游戏中达到的最高等 级、消息应用中的聊天记录、新闻应用中上一次同步的文章、已登录用户的证书，或者 仅仅是用户已经使用过的引导图标记符。 热(重)启动 这是指当应用处于后台，但并未被挂起或关闭时，用户切换至应用而触发的启动。在这 种情况下，当用户通过点击应用图标或深层链接,返回应用时，不会触发 启动时的回调，而是直接用 applicationDidBecomeActive:（或 application:openURL:so urce:annotation:）回调。 升级后启动 应用升级以后的启动。通常而言，升级后的启动与冷启动没有差别。 6. 用户界面6.1 视图控制器视图控制器的生命周期。 视图初始化时会涉及两个方法—— loadView 和 viewDidLoad 。当添加一个新的视图控制器时， 通过 Xcode 生成的模板代码只有 viewDidLoad 方法。当视图控制器的 view 被请求时， loadView 方法会被调用，但因为它还未被创建，所以会是 nil 。 视图会通过以下三种方式加载： 从 nibs 使用故事板（使用 UIStoryboardSegue ） 使用自定义代码创建 UI 如果通过覆写loadView 方法创建了自定义 UI，你需要牢记以下几点。 将 view 属性设置到视图层级的根上。 确保视图正被其他的视图控制器所共享。 不要调用 [super loadView] 。 书上剩下的知识点比较常见，如 TableView，UIWebView介绍等，不做更多笔记. 7 网络8 数据共享9 安全后续章节没有更多好的知识点，本书比较好的还是前半段关于内存知识点，更多知识点可以学习日本大佬写的那本 内存管理的书,看完这本书与另外搜索的笔记让一些模糊知识点变得清晰","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"iOS音量控制界面控制Tips","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/iOSVolumeViewTips/","text":"iOS音量控制界面控制TipsAVFoundation 框架提供了播放音频和视频的工具，使用 AVFoundation 基本能满足我们的大部分的播放需求。 在一些需求开发中,通常有一些骚操作需要自定义或者隐藏音量控制界面 MPVolumeView先看看官方的解释 A slider control used to set the system audio output volume, and a button for choosing the audio output route. Use a volume view to present the user with a slider control for setting the system audio output volume, and a button for choosing the audio output route. When first displayed, the slider’s position reflects the current system audio output volume. As the user drags the slider, the changes update the volume view. If the user presses the device volume buttons while sound is playing, the slider moves to reflect the new volume. MPVolumeView是系统级别的音量控制View,但是他并不是一个单例全局获得,不是通过类似 UIApplication 来获得，他只是简单就能获得 1_systemVolumeView = [[MPVolumeView alloc]initWithFrame:CGRectZero]; 当然不是说只是把他设置Frame 为0就可以简单隐藏，也不能通过设置 _systemVolumeView.hidden = YES 隐藏 通常做法就是将其添加到屏幕外位置达到隐藏效果。 此时需要注意的是，如果你把系统的音量控制View隐藏了，切回后台调节音量也是不会显示的，你要_systemVolueView移除,才会重新出现. 回到项目需求上一切都是需求驱动技术，先说下最近的需求 需求要求是自定义相机里面，通过按下音量键做到拍照功能且音量不变化 先说下思路: 首先进到功能页面需要隐藏MPVolumeView 监听系统音量变化通知或者KVO，总之就是监听音量变化，获得前后音量大小 改动音量，保持不变 调用拍照方法 切换到后台时候重新显示系统音量，切换回来App重新隐藏 确定了思路之后开始设计结构,由于之前写了一篇技术博文，也是关于这方面控制的，本以为只是简单的操作下就好，怎么知道也是有很多坑.博文: iOS7 以上监听音量键Tips 本来只是平移移植过来，以为就能用了，怎么知道出现了切换到后台，按了下音量切换回App还是出现音量View. 由于原来那套部署在另外App上，而且也是几年前写的，也可能每个App业务逻辑上不同，也会导致这个问题。 所以需要重新设计一套成熟一点的框架与架构 MPVolumeObserver这次搜索过一些博客文章，文章方法基本都是不行的。直到参考了一个github库 VolumeBar,也大概了解到为什么原来那套方案切换到后台调整音量后，切换回App就会显示. 首先原来那套方案,使用单例全局管理了一个音量控制类.初始化时候将MPVoluemeView 创建了就加到当前屏幕window 看不见的地方, 暂停时候也没有去除。后来我也试过手动在stopObserver停止监听中,将MPVolumeView移除，后来就出现上面所说问题，回到App重新添加，即使添加到看不见地方也是会出现 先说下这个架构,MPVolumeObserver是个全局单例，监听系统与用户事件,如切换到后台，切换回前台，音量变化. MPVolueObserver中包括两个小类 JNEMPVolumeObserverWindow(用于承载MPVolumeView的伪造window,不参加用户操作反馈) 、JNEMPVolumeManager(监听系统音量变化) MPVolumeObserverWindow参考了这个库，得出结论是，开始监听时候，需要创建一个window之类的承载体.（这个也是可能原来那套方案问题，因为原来是添加到当前window最顶层，删除添加都是基于这层的。可能系统只是支持一次添加，删除后再添加就能隐藏了(自己猜测且实践过).所以每次创建的这个新的 window 载体设置了大小，添加这个系统MPVoluemeview，且这个window可以隐藏 1234567//MPVolumeObserver _obWindow = [[JNEMPVolumeObserverWindow alloc]initWithViewController:vc];//JNEMPVolumeObserverWindow _systemVolumeView = [[MPVolumeView alloc]initWithFrame:CGRectZero]; [self addSubview:_systemVolumeView]; //blablabla MPVolumeManager这个是监听系统音量的类，之前方案是监听系统通知 SystemVolumeDidChange , 但是研究过这个，因为通知名是私有的，苹果爸爸到时改了就没法用了。所以现在方案是使用KVO 监听AVAudioSession的 outputVolume 来实现音量监听 此时再说明下AVAudioSession 可以看到AVAudioSession就是用来管理多个APP对音频硬件设备（麦克风，扬声器）的资源使用。 举例一下AVAudioSession可以做这些事情 设置自己的APP是否和其他APP音频同时存在，还是中断其他APP声音 在手机调到静音模式下，自己的APP音频是否可以播放出声音 电话或者其他APP中断自己APP的音频的事件处理 指定音频输入和输出的设备（比如是听筒输出声音，还是扬声器输出声音） 是否支持录音，录音同时是否支持音频播放 MPVolumeManager中每次监听需要激活一下AVAudioSession 12//激活AVAudioSession[session setActive:YES error:nil]; 即可开始监听系统音量 最后的最后，献上这个音量库: MPVolumeObserver Reference1.iOS-音频-AVAudioSession","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"ipa 在线下载安装方法（itms-services）","date":"2019-09-24T07:31:27.135Z","path":"2019/09/24/ipaOnlineDownload/","text":"ipa 在线下载安装方法（itms-services）最近在学习 iOS 逆向这方面知识，逆向完成后，生成一个ipa包，然后再通过 某P助手 安装到手机上.如果想分享给别人使用还要通过真机编译更加麻烦.(当然手机在证书的绑定机子列表里面,并不是免签名越狱机子那种)然后想起了 蒲公英 与 fir 平台，(代码分发),就好奇它的实现方法,刚好手机购买了 JSBox App，一个非常赞的App，通过自己写脚本可以实现一堆功能。 上面有一个脚本可以本机下载 iCloud 上的 ipa 进行安装，就研究脚本原理. itms-services脚本中主要用到的是这个苹果协议 itms-services itms-services 协议常用于 iOS 企业应用的无线部署，这可在不使用 iTunes 的情况下将内部软件发布或者分享给用户。 流程html部署实现在线下载ipa方法其实很简单.首先需要一个网页，safari 浏览器访问然后点击链接下载，如同 蒲公英 与 fir 平台做法. 那么 ，链接 a 标签里面应该写什么呢? 1&lt;a href=\"itms-services://?action=download-manifest&amp;url=https://****/***.plist\"&gt; xxx &lt;/a&gt; url= 后面plist的链接要求一定是https的，而且必须是公网ssl，自签名及免费的https不可用。此处推荐 码云 , Github 等自带 https 平台，plist只需上传托管，通过 Raw 形式查看即可获得 plist 的地址,以码云 代码托管平台为例, 点击后即可在浏览器获得地址，然后替换掉 html 标签里面数据 plist 文件plist文件如何写呢？如下: 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://此处为ipa地址,可以使用http或https&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;*&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;App名字，可随意，网页点击下载时候弹框标识&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 那么简单的 ipa在线下载就完成了","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"2018阅读清单","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/2018ReadingList/","text":"轻量级低风险 iOS Hotfix 方案 iOS 性能优化的探索 iOS App 签名的原理 iOS新闻类App内容页技术探索 Cocoapods原理总结","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"Cocoapod中静态库与动态库","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/CocoapodStaticAndDynamicFrameworkStudy/","text":"最近在做一个需求时候，对 Cocoapod 有了一次新的理解，故做下笔记记录一下知识点. CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。 CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。 以上是 Cocoapod 的一些介绍,所以可以理解成使用第三方库的工具 iOS中的cocoapods, 像 node中的 npm+grunt. Android 的 gradle 以下代码是普通的项目中 cocopod 配置写法: 12345678910#公共Pod仓库的索引,通过这个仓库里面的索引找到所有第三方库的github地址source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &apos;项目Target名字&apos; do pod &apos;MJExtension&apos; # blablabla 一些第三方库依赖end 通过在项目根目录下生成 Podfile 并运行 pod install 能为项目自动引入第三方依赖，方便快捷. 再大的项目最初都是从 Xcode 提供的一个非常简单的工程模板慢慢演化来的。在项目的演化过程中，为了实现新的功能，不断有新的类被创建，新的代码被添加。不过除了自己添加代码，我们也经常会直接把第三方的开源代码导入到项目中，从而避免重复造轮子，节约开发时间。 所以使用 Cocoapods 的好处有如下几个: 避免直接导入文件的原始方式，方便后续代码升级 简化、自动化集成流程，避免不必要的配置 自动处理库的依赖关系 简化开发者发布代码流程 以上就是简单的对 Cocoapod 使用入门,下面就开始动态库与静态库研究 前言在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。 由于上面的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如微信的SDK）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用 iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以）.为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework（可植入性Framework）。 划一下重点Embedded Framework iOS 出现了APP Extension，swift编程语言也诞生了，由于 iOS 主 APP 需要和 Extension 共享代码，Swift 语言的机制也只能有动态库，于是提出了一个概念Embedded Framework，这种动态库允许APP 和 APP Extension共享代码，但是这份动态库的生命被限定在一个 APP 进程内。简单点可以理解为 被阉割的动态库 动态库静态库静态库和动态库都是以二进制提供代码复用的代码库 动态库形式：.dylib和 .framework 静态库形式：.a 和 .framework 静态库和动态库的区别静态库：链接时会被完整的复制到可执行文件中，所以如果两个程序都用了某个静态库，那么每个二进制可执行文件里面其实都含有这份静态库的代码 动态库： 链接时不复制，在程序启动后用 dyld 加载，然后再决议符号，所以理论上动态库只用存在一份，好多个程序都可以动态链接到这个动态库上面，达到了节省内存(不是磁盘是内存中只有一份动态库)，还有另外一个好处，由于动态库并不绑定到可执行程序上，所以我们想升级这个动态库就很容易，windows 和 linux 上面一般插件和模块机制都是这样实现的。 上图中的绿框表示app的可执行文件。 在 iOS 平台上规定不允许存在动态库，并且所有的 IPA 都需要经过苹果爸爸的私钥加密后才能用，基本你用了动态库也会因为签名不对无法加载,所以 iOS8 之后就出现了上面的 阉割版动态库 Embedded Framework .a是一个纯二进制文件,不能包含其他的资源文件，.framework中除了有二进制文件之外还有资源文件。 .a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。 .a +.h + sourceFile =.framework 静态库和动态库的加载编译: 将我们的源代码文件编译为目标文件 链接: 将我们的各种目标文件加上一些第三方库，和系统库链接为可执行文件。 由于某个目标文件的符号(可以理解为变量，函数等)可能来自其他目标文件，其实链接这一步最主要的操作就是 决议符号的地址。 若符号来⾃静态库(本质就是.o 的集合包)或 .o，将其纳⼊链接产物，并确定符号地址 若符号来⾃动态库，打个标记，等启动的时候再说—交给 dyld 去加载和链接符号 于是链接加装载就有了不同的情况 Load 装载：将库⽂件载⼊内存 Static Loading：启动时 Dynamic Loading：启动后（使⽤时） Link 链接：决议符号地址 Static Linking：构建（链接）时 Dynamic Linking：运⾏时（启动时或使⽤时） 组合起来就是 2 * 2 = 4 了 Static Loading + Static Linking Static Loading + Dynamic Linking Dynamic Loading + Dynamic Linking Dynamic Loading + Static Linking 第一种是纯静态库相关了 第二种就是静态加载(启动时)，动态链接 ，链接时，动态库参与链接，但是这时候只是给符号打了标记告诉我这个符号来自与动态库，程序启动时，iOS 或者 Mac OS 操作系统的 dyld 自动 load + link。既然全部都是自动的。那么符号的调用方完全不知道你到底是源码还是静态库，动态库 。 第三种收到调用 dlopen + performSelector，由于不能上架，通常用于线下开发( 著名的 Injection) 动静态库对比Apple 官方推荐每个 App 使用 Dynamic Framework 的数量是 6 个，这是有原因的。因为在 App 启动的时候，dyld 会load 这些动态库，这会造成启动时间的增加；而且动态库数量过多，还会在 iOS 9 的设备上造成 dyld 的 crash。 但是，并不是全部达成静态库就很好，因为打成静态库，会导致包增大，所以需要根据项目来选择静态库还是动态库。目前来说，如果引入了 swift 库的话，基本 cocoapod 都打成了动态库, 不然无法编译，但是好像也有办法解决，比较麻烦，我的理解来说，当然一些简单功能实现，没必要使用第三方库.(维护是个问题，另外，使用第三方库，很多糅杂的类与方法不需要使用，导致以后启动速度变慢)，最好就是简单的功能，参考源码自己写一套。第一可以提高自己对源码，框架设计的理解，第二自己写的东西知道流程方便维护。当然一些经历了长时间迭代的框架库直接使用就行了(如 AFNetworking , SD等,没必要重复造轮子). 当然还有一些特殊情况下是需要使用动态库的,如: iOS9 以下对 __text 段 60M 的限制使用了动态库方案 自动化动静态库依赖历史早期的项目iOS开发早期未形成工程化的时候，是不存在所谓依赖管理的概念的，早期 iOS 开发如果想要使用第三方库，是非常繁琐的一件事情。 将第三方库源代码复制到工程目录，或者使用 git submodule 将其作为项目的一个模块 设置工程文件，添加第三方库依赖的系统库 对于某些第三方库，可能需要设置一些编译选项（ etc. -fno-objc-arc） 最后就是管理第三方库代码的更新 iOS 开发终究还是很传统的 Unix 开发，直接把第三方库源代码抽离出来，打包成静态库就行了（PS：在 iOS 8 之前苹果只允许使用静态库，而 iOS 8 后就可以打包动态库了，当然，实际上是一样的。）。这样的话就不需要担心过多的源代码导入的繁琐，也不需要担心第三方库究竟需不需要编译选项，而且第三方库更新只需要更新静态库就行了 进化中的项目配置封装成静态库或动态库看起来确实美好了，方便快捷，这也是 Unix 下的解决方案。但是只要仔细一想，问题一大堆。 某些第三方库很可能直接依赖另一项第三方库，依赖如果使用手工解决将会是很大的工作。 动态库不能用于 iOS 7 及以下版本 工程依旧需要设置依赖的系统库 仍然需要手工更新第三方库版本 对于 Unix 环境来说，动态库可以存放在系统默认搜索路径下，这样所有的应用都可以共享同一个内存副本，而且升级动态库的时候可以一起升级，不需要到各处寻找。但是 iOS 的动态库实际上是缩水的，因为苹果将动态库限制在了沙盒内部，其他 App 完全不能访问此动态库。这就限制了动态库的优点。还有一点原因就是指令集架构的不同，iOS 模拟器使用的是 x86 架构指令集，而真机则是 ARM64 等指令集，如果想要方便使用，最好需要打包通用架构的静态库，但是这是很繁琐的工作。由于以上原因，手工封装静态库或者动态库实际上在项目小的时候是可以的，但是项目规模一旦扩大就会导致效率低下。 自动化依赖时代为了能够自动化流水作业，就引出了依赖包管理的概念，也就是 Cocoapods。Cocoapods 本质上还是上面所说的封装动态库静态库，但是它解决的最大问题就是依赖管理。开发者不需要从 Github 的地方辛苦的寻找代码，只需要一条命令，就能下载整合第三方库。 至于为什么可以自动化依赖，这里不做更多叙述可以阅读文章 : Cocoapods原理总结 上面说了一下历史进程，下面说下一些坑 静态库的坑在使用 静态库 打包组件或者第三方库时候,有时候会遇到相同名字的函数，会在调用相同方法时候，有时候会出现崩溃,因为，在 link 静态库时候，linker 会把它需要的东西复制到可执行文件中，在 Static Library 中的函数符号出现在了最后的 binary 中（T 代表全局代码段符号），但由于这两个函数的名字都是 test，最终只有一个函数实现被合并进去了（有点像 Category方法覆盖）。具体可以阅读下方 [1] 的链接 Cocoapod使用动静态库在 podfile 中使用 添加 use_frameworks! 即可将所有第三方库打包成动态库,不添加的话就是打包成静态库(注:暂时来说如果使用了第三方swift库，一定需要打成静态库!),如果你的第三方库里面包含了静态库，(如什么百度地图，微信等那些,比较难解决了) 暂时了解到(2019.04.28), 有几种操作: 在 cocoapod1.5.0 版本之后，不使用 use_frameworks!,使用 use_modular_headers!打成静态库. 然后其他 oc 库后面需要添加 :modular_headers =&gt; false , 如 : pod &#39;YYKit&#39;,:modular_headers =&gt; false 将静态库重新包一层动态库来使用, 先挖个坑，迟点看有没有时间做个 Demo，原理如下 静态库和动态库依赖关系第一种静态库互相依赖，这种情况非常常见，制作静态库的时候只需要有被依赖的静态库头文件在就能编译出来。但是这就意味者你要收到告诉使用者你的依赖关系。 第二种动态库依赖动态库，两个动态库是相互隔离的具有隔离性。在制作的静态库的时候需要被依赖动态库参与链接，最终具体的符号决议交给dyld来做。 第三种，静态库依赖动态库，也很常见，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。 第四种，动态库依赖静态库，这种情况就有点特殊。首先我们设想动态库编译的时候需要静态库参与编译，但是静态库交由dyld来做符号决议，这和我们前面说的就矛盾了啊。静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。 利用动态库解决相关问题 处理多个动态库依赖一个静态库问题通过前面我们知道可执文件（主程序或者动态库）在构建的链接阶段，遇到静态库，吸附进来；遇到动态库，打标记，彼此保持独立。 正因为动态库是保持独立的，那么我们可以自定义一个动态库把依赖的静态库吸附进来。对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题。 总结通过上面的研究与资料收集，动静态区别可以归纳成下面表格 动态库和静态库的区别如下 动态库 静态库 命名空间 有单独的命名空间,不同库同名文件不会冲突 使用import&lt;XXX/xxx.h&gt;的方式引入 没有单独命名空间,同名文件冲突 引入方式import”xxx.h” 加载时机 在启动时加载,加载时间较长 构建时加载 依赖关系 可以依赖动态库,不能依赖静态库 可以依赖动态库和静态库 是否能使用swift 可以包含swift文件 在cocoapods1.4.0之后,可以使用use_framework!的方式包含swift文件 framework支持static_framework 根据不同项目合理选用技术是必要的，在我看来，由于项目中必定存在第三方，其实少量第三方使用动态库，对启动速度影响并不是太大的，可以放心使用动态库。由于swift不支持静态库，未来也会出现更多第三方swift库，与其将swift库静态化，还不如将静态库动态化(静态库上套多一层 .framework)来实现组件化 另外可以通过 file这个命令判断库是静态库还是动态库 是 .framework 里面的可执行文件才能执行这个 Reference1.两个 Framework 中如果定义了相同名字的 C 函数会发生什么？ 2.理解Cocoapods 3.iOS动态库、静态库及使用场景、方式 4.iOS 动态库和静态库简介 5.升级 CocoaPods 1.5，使用 Swift Static Framework *6.组件化-动态化实践 7.cocoapods的静态库和动态库","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"动态路由","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/DynamicRouter/","text":"什么是移动端路由层：路由层的概念在服务端是指url请求的分层解析，将一个请求分发到对应的应用处理程序。移动端的路由层指的是将诸如App内页面访问、H5与App访问的访问请求和App间的访问请求，进行分发处理的逻辑层。 移动端路由层需要解决的问题： 对外部提供远程访问的功能，实现跨应用调用响应，包括H5应用调用、其他App应用调用、系统访问调用等 原生页面、模块、组件等定义，统称为资源(Resource)，在跨应用调用和路由层在不同端实现的业务表现需要一致的前提下，需要对资源进行定义，在路由提供内部请求分发的时候则可以提供不依赖对外进行资源定义的功能 外部调用如何使用统一标示(Uniform)进行表示资源 如何在移动端统一定义访问请求的过程，从而达成移动端与web端的统一性 如何更好的兼容iOS、Android的系统访问机制、App链接协议、web端路由机制与前端开发规范等 如何兼容各平台(Android、iOS)App页面导航机制 如何解决安全访问问题 移动端在客户端进行动态配置 动态路由试手参考了项目中同事写的动态路由模块，发现写的不错，故模仿了一个写。项目中，我们使用动态路由器，实现模块间Controller的跳转传值，做到 解耦 作用 不用于以前的 1#import xxxx 模块， 然后 123xxx = [[xxxviewcontroller alloc]init];[self.navigationcontroller push xxx...]; 使用动态路由器，只需要在项目中plist注册好对应的模块和id，直接可以push过去，而且还能传参 模块结构 Navigation作为项目的根导航，包含了一个Router单例类，根据传入的 模块名字 或者 模块id ，做相应跳转 用到的ViewController皆继承 SYPageViewController， SYPageViewController 遵守SYRouterJumpProtocol 协议里面是一些跳转方法，在SYPageViewController 的扩展类 SYRouterViewController+SYRouterProtocolAddition 中实现 实现原理，调用自身所在的根导航栏 SYRouterNavigator 中的Router类跳转方法实现跳转 总结动态路由的试手，可能存在很多不足，动态路由器很有效解决了模块间的依赖问题，达到解耦作用 GitHub地址: https://github.com/swlfigo/SYDynamicRouter","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"链式编程思想-函数式变成思想计算器","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/FunctionProgrameThinking/","text":"编程思想先简单介绍下目前已知的编程思想。 面向过程：处理事情以过程为核心，一步一步的实现。 面向对象：万物皆对象 链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3) 链式编程特点 : 方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值） 代表 : Masonry 响应式编程思想 : 不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。 代表 :KVO 函数式编程思想 是把操作尽量写成一系列嵌套的函数或者方法调用 函数式编程特点 : 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 代表 : ReactiveCocoa - 链式编程思想 1&gt;一般开发习惯把事情封装到一个方法中；链式编程思想是把要做的事情封装到block中，给外部提供一个返回这个block的方法 2&gt;链式编程思想方法特点:方法的返回值必须是block，block的参数是需要操作的内容，block的返回值是返回这个block的方法的调用者 1 尝试设计成类方法1.1不知道方法的返回值 就返回void add方法无法连续调用,所以add方法必须返回 CalculateMaker类 1.2 方法返回值是类本身 需要把累加的结果保存起来,但是类方法不能使用属性，使用static 静态全局变量 2 设计成对象方法add方法要连续调用,add方法就要返回CalculateMaker类的对象实例 CalculateMaker.h 123456#import &lt;Foundation/Foundation.h&gt;@interface CalculateMaker : NSObject@property (nonatomic,assign) int result;- (instancetype)add:(int)num;@end CalculateMaker.m 12345678#import \"CalculateMaker.h\"@implementation CalculateMaker- (instancetype)add:(int)num&#123; _result += num; return self;&#125;@end 实现:123456CalculateMaker *maker = [[CalculateMaker alloc] init];int result = [[[[maker add:10] add:10] add:10] result];NSLog(@\"result = %d\",result);//CalculateMaker[8230:1471099] result = 30 3.链式编程的可读性 返回值是block类型1maker.add(10).add(20).add(30).add(40) 只有返回值是block才能实现该效果 3.1 add方法返回值是block,block类型无参数无返回值12345678910111213141516171819//.h//返回值block,block类型无参数无返回值- (void(^)())add;//.m- (void (^)())add&#123; return ^&#123; NSLog(@\"返回一个block,该block无参数无返回值\"); &#125;;&#125;//implementationCalculateMaker *maker = [[CalculateMaker alloc] init];maker.add();//CalculateMaker[10247:1491527] 返回一个block,该block无参数无返回值 CalculateMaker类的实例有一个add方法,调用add方法返回值是一个block,外部拿到这个block可以block();执行里面封装的代码 计算的操作在block中完成,外部不需要知道block的实现细节,外部只是调用执行该block即可 3.2 add方法返回值是block, block类型有参数(int)无返回值12345678910111213- (void(^)(int num))add;- (void (^)(int))add&#123; return ^(int num)&#123; NSLog(@\"add方法返回一个block,该block有int参数无返回值\"); &#125;;&#125;CalculateMaker *maker = [[CalculateMaker alloc] init];maker.add(10);// CalculateMaker[11045:1497617] add方法返回一个block,该block有int参数无返回值 链式编程思想 : 把业务逻辑的实现封装在block，把block返回到外部执行如何连续执行add方法,让这个block执行完毕返回CalculateMaker类的对象实例即可 3.3add方法返回值是block, block类型有参数(int)有返回值(类的对象实例)123456789101112- (instancetype (^)(int num))add;- (instancetype (^)(int))add&#123; return ^(int num)&#123; NSLog(@\"add方法返回一个block,该block有int参数有返回值是类的对象实例\"); return self; &#125;;&#125;CalculateMaker *maker = [[CalculateMaker alloc] init];maker.add(10).add(20); 不能使用instancetype 123456789101112- (CalculateMaker* (^)(int num))add;- (CalculateMaker* (^)(int))add&#123; return ^(int num)&#123; NSLog(@\"add方法返回一个block,该block有int参数有返回值是类的对象实例\"); return self; &#125;;&#125;CalculateMaker *maker = [[CalculateMaker alloc] init];maker.add(10).add(20); 4. 所有的NSObject都能计算 分类让所有的OC的类都能计算，给所有的类分类出一个方法，把实现计算的操作聚合在一个block代码块中 CalculateMaker.h 123456789#import &lt;Foundation/Foundation.h&gt;@interface CalculateMaker : NSObject@property (nonatomic,assign) int result;- (CalculateMaker* (^)(int num))add;@end CalculateMaker.m 123456789101112#import \"CalculateMaker.h\"@implementation CalculateMaker- (CalculateMaker* (^)(int))add&#123; return ^(int num)&#123; _result += num; return self; &#125;;&#125;@end NSObject+Calculate.h 123456#import &lt;Foundation/Foundation.h&gt;#import \"CalculateMaker.h\"@interface NSObject (Calculate)+ (int)makeCalculate:(void (^) (CalculateMaker *))block;@end NSObject+Calculate.m 1234567891011121314#import \"NSObject+Calculate.h\"@implementation NSObject (Calculate)+(int)makeCalculate:(void (^)(CalculateMaker *))block&#123; // 计算制造者 CalculateMaker *maker = [[CalculateMaker alloc] init]; // 执行计算 block(maker); // 返回计算结果 return maker.result;&#125;@end 12345678//implementationint result = [NSObject makeCalculate:^(CalculateMaker *maker) &#123; maker.add(1).add(2).add(3); maker.add(4).add(5).add(6); &#125;]; NSLog(@\"result = %d\",result); - 函数式编程思想 函数式编程思想 : 是把操作尽量写成一系列嵌套的函数或者方法调用 函数式编程本质 : 就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理 函数式编程特点 : 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 实现1234567891011121314151617181920212223242526272829//.h@property (nonatomic, assign) int result;- (instancetype)PH_calculate:(int(^)(int))calculateBlock;//.m- (instancetype)PH_calculate:(int (^)(int))calculateBlock&#123; _result = calculateBlock(_result); return self;&#125;//implementationPHCalculateManager *calculateManager = [[PHCalculateManager alloc] init]; int result = [[calculateManager PH_calculate:^int(int result) &#123; // 存放所有的计算代码 result += 8; result *= 8; result -= 4; result /= 3; return result; &#125;] result]; NSLog(@\"%d\",result); &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"GCD学习","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/GCDLearn/","text":"重新复习GCD– 对GCD重新复习一次，加深了解 多线程概念进程 正在进行中的程序被称为进程，负责程序运行的内存分配 每一个进程都有自己独立的虚拟内存空间 线程 线程是进程中一个独立的执行路径(控制单元) 一个进程中至少包含一条线程，即主线程 可以将耗时的执行路径(如：网络请求)放在其他线程中执行 细说GCD（Grand Central Dispatch）GCD（Grand Central Dispatch） 介绍GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址 http://libdispatch.macosforge.org .GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。 GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。 GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。 GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。 GCD概要 和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。 操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在这个并行队列在队列中被分配的那个线程执行。 GCD基本思想GCD的基本思想是就将操作s放在队列s中去执行 操作使用Blocks定义 队列负责调度任务执行所在的线程以及具体的执行时间 队列的特点是先进先出(FIFO)的，新添加至对列的操作都会排在队尾 队列 (dispatch_queue_t) 串行队列，队列中的任务只会顺序执行 并行队列，队列中的任务通常会并发执行 操作 dispatch_async 异步操作，会并发执行，无法确定任务的执行顺序 dispatch_sync 同步操作，会依次顺序执行，能够决定任务的执行顺序 注: 队列不是线程.也不表示对应的CPU 队列就是负责调度的!谁空闲，就把任务给谁！ 多线程技术的目的，就是为了在一个CPU上实现快速切换！ 并发队列 串行队列(非主队列) 主队列(只有主线程,串行队列) 同步(dispatch_sync) 不开启新的线程，串行 不开启新的线程，串行 不开启新的线程，串行 异步(dispatch_async) 开启新的线程，并发 开启新的线程，串行 不开启新的线程，串行 GCD 术语– Serial vs. Concurrent 串行 vs. 并发描述当前任务相对于其它任务被执行，串行执行就是每次只有一个任务被执行，并发执行就是在同一时间可以有多个任务被执行。 Synchronous vs. Asynchronous 同步 vs. 异步一个_同步_函数 dispatch_sync 只在完成了它预定的任务后才返回。把一个任务添加到某queue后,等这个任务完成,调用线程才继续执行. 一个_异步_函数 dispatch_async ，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。 把一个任务添加到某queue后就马上离开,而不管任务在那个queue里的执行状态 基本概念– 系统标准两个队列 1234//全局队列，一个并行的队列dispatch_get_global_queue//主队列，主线程中的唯一队列，一个串行队列dispatch_get_main_queue 自定义队列 1234//串行队列dispatch_queue_create(\"com.sylar.serialqueue\", DISPATCH_QUEUE_SERIAL)//并行队列dispatch_queue_create(\"com.sylar.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT) 同步异步线程创建 1234//同步线程dispatch_sync(..., ^(block))//异步线程dispatch_async(..., ^(block)) 队列（dispatch queue）– Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。 12dipatch_queue_t queue;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0); User create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。 12dispatch_queue_t queuequeue = dispatch_queue_create(\"com.sylar.gcddemo.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT); 自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级 12345678//dipatch_queue_attr_make_with_qos_classdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);dispatch_queue_t queue = dispatch_queue_create(\"com.sylar.gcddemo.qosqueue\", attr);//dispatch_set_target_queuedispatch_queue_t queue = dispatch_queue_create(\"com.sylar.gcddemo.settargetqueue\",NULL); //需要设置优先级的queuedispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); //参考优先级dispatch_set_target_queue(queue, referQueue); //设置queue和referQueue的优先级一样 dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下 12345678910111213141516171819202122232425dispatch_queue_t serialQueue = dispatch_queue_create(\"com.sylar.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL);dispatch_queue_t firstQueue = dispatch_queue_create(\"com.sylar.gcddemo.firstqueue\", DISPATCH_QUEUE_SERIAL);dispatch_queue_t secondQueue = dispatch_queue_create(\"com.sylar.gcddemo.secondqueue\", DISPATCH_QUEUE_CONCURRENT);dispatch_set_target_queue(firstQueue, serialQueue);dispatch_set_target_queue(secondQueue, serialQueue);dispatch_async(firstQueue, ^&#123; NSLog(@\"1\"); [NSThread sleepForTimeInterval:3.f];&#125;);dispatch_async(secondQueue, ^&#123; NSLog(@\"2\"); [NSThread sleepForTimeInterval:2.f];&#125;);dispatch_async(secondQueue, ^&#123; NSLog(@\"3\"); [NSThread sleepForTimeInterval:1.f];&#125;);2017-09-21 00:01:41.421 GCDDemo[1622:150923] 12017-09-21 00:01:44.427 GCDDemo[1622:150923] 22017-09-21 00:01:46.429 GCDDemo[1622:150923] 3(设置为串行队列了) 队列类型队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为 QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。 何时使用何种队列类型 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。 dispatch_once用法 dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例 12345678910+ (UIColor *)boringColor;&#123; static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; &#125;); return color;&#125; dispatch_async设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列 123456789- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;&#123; dispatch_async(self.isolationQueue, ^(void)&#123; // do actual processing here dispatch_async(self.resultQueue, ^(void)&#123; handler(YES); &#125;); &#125;);&#125; 可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。 12345678910111213141516171819//代码框架dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 &#125;);&#125;);//下载图片的示例dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSURL * url = [NSURL URLWithString:@\"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg\"]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;); &#125;&#125;); dispatch_after延后执行dispatch_after只是延时提交block，不是延时立刻执行。 12345678- (void)foo&#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; [self bar]; &#125;);&#125; dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样 1234567891011121314151617181920212223242526272829- (void)dispatchBarrierAsyncDemo &#123; //防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。 dispatch_queue_t dataQueue = dispatch_queue_create(\"com.starming.gcddemo.dataqueue\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(dataQueue, ^&#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@\"read data 1\"); &#125;); dispatch_async(dataQueue, ^&#123; NSLog(@\"read data 2\"); &#125;); //等待前面的都完成，在执行barrier后面的 dispatch_barrier_async(dataQueue, ^&#123; NSLog(@\"write data 1\"); [NSThread sleepForTimeInterval:1]; &#125;); dispatch_async(dataQueue, ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@\"read data 3\"); &#125;); dispatch_async(dataQueue, ^&#123; NSLog(@\"read data 4\"); &#125;);&#125;//2017-09-26 23:07:17.135287+0800 GCDDemo[68558:2264984] read data 2//2017-09-26 23:07:19.138474+0800 GCDDemo[68558:2264982] read data 1//2017-09-26 23:07:19.138680+0800 GCDDemo[68558:2264982] write data 1//2017-09-26 23:07:20.138850+0800 GCDDemo[68558:2264981] read data 4//2017-09-26 23:07:21.141004+0800 GCDDemo[68558:2264982] read data 3 dispatch_apply进行快速迭代类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。 12345678910111213for (size_t y = 0; y &lt; height; ++y) &#123; for (size_t x = 0; x &lt; width; ++x) &#123; // Do something with x and y here &#125;&#125;//因为可以并行执行，所以使用dispatch_apply可以运行的更快- (void)dispatchApplyDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\", DISPATCH_QUEUE_CONCURRENT); dispatch_apply(10, concurrentQueue, ^(size_t i) &#123; NSLog(@\"%zu\",i); &#125;); NSLog(@\"The end\"); //这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行&#125; dispatch_apply能避免线程爆炸，因为GCD会管理并发 123456789101112131415161718- (void)dealWiththreadWithMaybeExplode:(BOOL)explode &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT); if (explode) &#123; //有问题的情况，可能会死锁 for (int i = 0; i &lt; 999 ; i++) &#123; dispatch_async(concurrentQueue, ^&#123; NSLog(@\"wrong %d\",i); //do something hard &#125;); &#125; &#125; else &#123; //会优化很多，能够利用GCD管理 dispatch_apply(999, concurrentQueue, ^(size_t i)&#123; NSLog(@\"correct %zu\",i); //do something hard &#125;); &#125;&#125; 配合 dispatch_group 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) &#123; i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123; if let completion = completion &#123; completion(error: storedError) &#125; &#125;&#125; Block组合Dispatch_groupsdispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。 当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。 123456789101112131415161718192021- (void)dispatchGroupWaitDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^&#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@\"1\"); &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@\"2\"); &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@\"go on\");&#125;//2017-09-28 15:02:10.213870+0800 GCDDemo[9837:401007] 2//2017-09-28 15:02:12.215037+0800 GCDDemo[9837:401004] 1//2017-09-28 15:02:12.215219+0800 GCDDemo[9837:400753] can continue//执行完group里面所有任务才继续//串行卡在这里 dispatch_group_notify1234567891011121314151617181920212223- (void)dispatchGroupNotifyDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.starming.gcddemo.concurrentqueue\",DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@\"1\"); &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@\"2\"); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@\"end\"); &#125;); NSLog(@\"can continue\");&#125;//2017-09-28 15:07:45.379203+0800 GCDDemo[9929:411297] can continue//2017-09-28 15:07:45.379203+0800 GCDDemo[9929:411654] 2//2017-09-28 15:07:45.379203+0800 GCDDemo[9929:411652] 1//2017-09-28 15:07:45.385121+0800 GCDDemo[9929:411297] end//执行后代码会继续，所有任务完成后才会回调//约等于 通知 注意事项： dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。 dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的 GCD死锁当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)deadLockCase1 &#123; NSLog(@\"1\"); //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@\"2\"); &#125;); NSLog(@\"3\");&#125;- (void)deadLockCase2 &#123; NSLog(@\"1\"); //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@\"2\"); &#125;); NSLog(@\"3\");&#125;- (void)deadLockCase3 &#123; dispatch_queue_t serialQueue = dispatch_queue_create(\"com.starming.gcddemo.serialqueue\", DISPATCH_QUEUE_SERIAL); NSLog(@\"1\"); dispatch_async(serialQueue, ^&#123; NSLog(@\"2\"); //串行队列里面同步一个串行队列就会死锁 dispatch_sync(serialQueue, ^&#123; NSLog(@\"3\"); &#125;); NSLog(@\"4\"); &#125;); NSLog(@\"5\");&#125;- (void)deadLockCase4 &#123; NSLog(@\"1\"); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"2\"); //将同步的串行队列放到另外一个线程就能够解决 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@\"3\"); &#125;); NSLog(@\"4\"); &#125;); NSLog(@\"5\");&#125;- (void)deadLockCase5 &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"1\"); //回到主线程发现死循环后面就没法执行了 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@\"2\"); &#125;); NSLog(@\"3\"); &#125;); NSLog(@\"4\"); //死循环 while (1) &#123; // &#125;&#125; RunLoop关系摘自 StackoverFlow The main thread’s run loop has a step in which it runs any blocks queued on the main queue.主线程的runloop有一个步骤，它在主队列上运行任何block。 GCD creates the threads for concurrent queues. A thread doesn’t have a run loop until the first time something running on the thread asks for the thread’s run loop, at which point the system creates a run loop for the thread. However, the run loop only runs if something on that thread then asks it to run (by calling -[NSRunLoop run] or CFRunLoopRun or similar). Most threads, including threads created for GCD queues, never have a run loop. GCD 创建并发队列的线程，线程的Runloop只在第一次运行时候请求runloop才会创建，也就是说系统为线程创建Runloop。Runloop只是在有队列任务请求时候才会运行，大部分线程，包括GCD队列的线程，并不会存在Runloop GCD manages a pool of threads and, when it needs to run a block (because it was added to some queue), GCD picks the thread on which to run the block. GCD’s thread-choosing algorithm is mostly an implementation detail, except that it will always choose the main thread for a block that was added to the main queue. (Note that GCD will also sometimes use the main thread for a block added to some other queue.) GCD管理线程池，当需要执行一些Block，GCD会选择一个线程去运行Block，GCD的 线程选择算法已经能帮用户实现大部分需求，除了主动添加在主线程上的Block（注：GCD有时候会利用主线程，添加一些Block到其他线程上） You can only get the run loop of the main thread (using +[NSRunLoop mainRunLoop] or CFRunLoopGetMain) or the run loop of the current thread (using +[NSRunLoop currentRunLoop] or CFRunLoopGetCurrent). If you need the run loop of some arbitrary thread, you must find a way to call CFRunLoopGetCurrent on that thread and pass its return value back across threads in a safe, synchronized way.你只能获得主线程runloop，如果你需要获得任意线程的Runloop，你需要找个方法调用那个线程的 CFRunLoopGetCurrent，同步形式下获得他的返回值 总结: 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。 队列无法销毁.只能挂起(NSOperation),同样，里面的线程也是挂起状态dispatch_async 同步，创建的线程由系统决定，由队列管理.","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"i5-9400f + ASUS TUF B360M Plus Gaming S 黑苹果之路","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/Hackintosh-i5-9400f-Tuf-B360M/","text":"最近工作需要组了一台黑苹果,配置如下: 电脑配置 规格 详细信息 CPU 英特尔i5 9400F 主板 ASUS TUF B360M-PLUS GAMING S (带S是某东特供版) 显卡 蓝宝石（Sapphire） RX590 8G D5 海外版 OC 内存 金士顿(Kingston) DDR4 2666 16GB 台式机内存 骇客神条 Fury雷电系列 (有需要就*2,后面补也不迟) 主硬盘 英特尔（Intel） 760P SSD NVMe 250G 次硬盘 Micron英睿达(Crucial) 500G SSD固态硬盘 SATA3.0接口 MX500系列 电源 航嘉 600w 直出 ——- 以下不是必备 ——- 散热 九州风神（DEEPCOOL）CPU散热器 240 一体水冷台式机组装游 哪些不能在Clover正常工作由于没有购置 蓝牙无线网卡 (例如免驱的 BCM943602CS ) ,所以无法测试蓝牙与airdrop是否正常工作,理论上打上驱动是没问题的 哪些能在Clover正常工作暂时用了这么久都能正常工作使用 [x] 正常上网 (由于公司使用的是 USB 外置网卡EP-AC1606 （8812AU) 需要安装驱动!, 自己测试过 使用网线也是能上网的,所以驱动正常！) [x] 能休眠,能唤醒,唤醒后无异样(如花屏,断网等) [x] 声卡能播放声音(并不是使用万能声卡驱动) [x] 能正常关机重启 [x] 能屏幕保护(有点低要求啊….) [x] DP口,HDMI口能用 [ ] 双屏输出(未测试,待后续更新) [x] USB口都能用 硬件参数参考这一部分介绍下买的硬件具体样子与参数,因为同一个东西也会翻车哦 (例如 RX580 2048SP 是无法免驱的…) 以下介绍图片 无 打广告行为 CPU: CPU来说只要不是买 AMD 就行了(没黑成分..毕竟白苹果没有用过AMD啊…不是不能上,又要折腾一番何必呢…) 另外就是注意买的CPU支持你的板子BIOS与针脚，比如你买的CPU很新，板子虽然支持这一代CPU，但是需要刷BIOS才认得出这种CPU，就不要搞了,BIOS 版本太新也会坑(后面会说一下我遇到的折腾的坑),上一下我的 CPU图吧 (注意: 9400f 不带显卡,9400f 不带显卡,9400f 不带显卡 重要事情说3次) 板子 板子也是很重要.不好的板子真的很多坑..这次选的 asus-tuf b360m 不知道是板子问题还是驱动问题，装起来各种翻车,后面安装部分会详细说 如果要找参考，就参考这个下面这个链接，老外黑苹果论坛总结的板子上黑苹果成功案例: 我是传送门 纵观现实很多案例，还是技嘉板子上比较稳，少点意外..(虽然我家是 华硕 Z270-AR + i7-7700) 另外个人建议还是上 Z 板子,扩展性很好!!!多接口真的好爽哦~ 另外下图是我在 某东 上购买的华硕板子 说下我选板子时候经验 首先我会看这个块板子，声卡与网卡型号,例如这块板子可以在华硕官网看到参数 我是传送门 注意到这张板子配置的是 Intel 1219V 与 ALC887 的网卡与声卡,剩下的可以 Google下是否存在这个型号的驱动 声卡可以在 GayHub 上查到 我是传送门 比如 ALC887 可以看到存在，点进去可以查看 layout-id 如图, layout-id 存在多个，只能在 Clover config.plist 一个个试了,试到满意音质为止,我这块板子13觉得不错~ 显卡: 显卡也是能不能上黑苹果的重要因素之一,由于不想折腾，我直接买了没核显的CPU，再另外配一张免驱的显卡上，免驱显卡列表可以看这里: 我是传送门 注意的还是那句,比如同一个型号的显卡也不能上 例如 RX580 oc, 与 RX580 2048sp… rx580 2048sp是不能免驱的！！！！！！！！！ 例如 讯景的 R580 ,还要另外刷Bios (这个听别人说的没试过,还是别碰讯景了…) 显卡的话还是认准 蓝宝石 和 迪兰 吧 重要事情说三次: N卡要打驱动，最高只支持到 10.13.6 , 不支持10.14+(除了免驱的非常旧的N卡) N卡要打驱动，最高只支持到 10.13.6 , 不支持10.14+(除了免驱的非常旧的N卡) N卡要打驱动，最高只支持到 10.13.6 , 不支持10.14+(除了免驱的非常旧的N卡) 不要再问 我的20xx , 10xx能不能上了!!","tags":[{"name":"Hackintosh","slug":"Hackintosh","permalink":"https://swlfigo.github.io/tags/Hackintosh/"}]},{"title":"Hello Metal","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/Hello Metal/","text":"Metal 简介Metal和OpenGL ES相似，它也是一个底层API，负责和3D绘图硬件交互。它们之间的不同在于，Metal不是跨平台的。与之相反的，它设计的在苹果硬件上运行得极其高效，与OpenGL ES相比，它提供了更快的速度和更低的开销。 注意: Metal应用不能跑在iOS模拟器上，它们需要一个设备，设备上装载着苹果A7芯片或者更新的芯片。所以要学习这篇教程，你需要一台这样的设备(iPhone 5S,iPad Air,iPad mini2)来完成代码的测试。Metal是一个底层3D绘图API，和OpenGL类似，但是它的开销更低。它是一个GPU上一个简单的封装，所以能够完成几乎所有事情，像在屏幕上渲染一个精灵（sprite）或者是一个3D模型。但你要编写完成这些事情的所有代码。这样麻烦的代价是，你拥有了GPU的力量和控制。没那么底层的游戏框架，像Sprite Kit、Scene Kit或者Unity都是在底层3D绘图API（像是Metal或是OpenGL ES）的基础上构建的。它们提供大部分你需要在游戏中编写的底层封装代码，比如在屏幕上渲染一个精灵(sprite)或者一个3D模型。 openGL 与 Metal 关系 下面让我们来对比一下Metal和OpenGL ES的不同之处。 OpenGL ES被设计成跨平台的。那意味着你可以用C++OpenGL ES的代码，在大部分情况下只要作少许改动就能让它在另一个平台上运行，比如Android。 苹果意识到尽管OpenGL ES对跨平台的支持很赞，但是它缺少了一些苹果设计产品的基本理念：苹果把操作系统、硬件、软件整合在了一起。 所以苹果认真考虑了如果他们设计一套特定基于他们硬件的绘图API，会是怎样呢？它的目标是极速运行、低开销以及支持最新最好的特性。 于是Metal诞生了。它对比OpenGL ES，能为你的应用单位时间内提高最高10倍的绘图调用次数。","tags":[{"name":"Metal","slug":"Metal","permalink":"https://swlfigo.github.io/tags/Metal/"}]},{"title":"Hexo 折腾","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/HexoBuilt/","text":"首先你要有一个GithubPage具体如何新建一个代码仓..请自行百度..过于简单不做讨论 Hexo简介Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 官网-&gt; Hexo传送门 Hexo 安装前准备（Mac环境下） 需要Node.js(如果安装了最好先卸载了再重新装) 需要Git (Mac环境自备了) GitHub SSH Key -&gt; 自行百度 -&gt; 用于更新博客（更可理解为git commit） Setp 1. node 是通过brew来安装的，所以第一步先安装brew 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; brew安装完后就通过它来安装node 12345#查看brew 是否安装成功brew -v #安装nodebrew install node 等待安装完成，测试是否安装成功 1234//查看版本node -vnpm -v 安装 Hexo 1npm install -g hexo-cli Step 2.安装完Hexo后，新建一个存放Blog的文件夹cd进去文件加里面 1hexo init //可初始化一个空Hexo项目//配置看官网//命令看官网","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://swlfigo.github.io/tags/Hexo/"}]},{"title":"MultipeerConnectivity框架，近场通信的基本使用","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/Multipeer connectivity Framework/","text":"Multipeer connectivity是一个使附近设备通过Wi-Fi网络、P2P Wi-Fi以及蓝牙个人局域网进行通信的框架。互相链接的节点可以安全地传递信息、流或是其他文件资源，而不用通过网络服务。此框架是在iOS7以后推出，旨在替代GameKit下的GKPeerPickerController通信。通过此框架我们可以直接连接同一网络下的设备，让其直接进行类似微信，qq那样的即时通讯效果。原理其中通讯的原理，是利用节点来进行广播服务（标示符），其他节点可以通过服务（标示符）发现广播。并对此节点进行连接。在项目中可以将广播和发现放在一起实现，这样既可以发现并连接到其他节点，同时也可以被其他节点所搜索链接。服务的命名规则为由ASCII字母、数字和“-”组成的短文本串，最多15个字符。通常，一个服务的名字应该由应用程序的名字开始，后边跟“-”和一个独特的描述符号 相关类针对于近场通信，在Multipeer connectivity框架中我们所需要学习的类如下: 1. MCPeerID //代表用户信息 2.MCSession //启用和管理Multipeer连接会话中的所有人之间的沟通。 通过Sesion，给别人发送和读取数据。 3.MCNearbyServiceBrowser //用于搜索附近的服务端，并可以对搜索到的服务端发出邀请加入某个会话中。 4.MCNearbyServiceAdvertiser //广播服务可以接收，并处理用户请求连接的响应。但是，这个类会有回调，告知有用户要与服务端设备连接，需要自定义提示框，以及自定义连接处理。 5.MCAdvertiserAssistant //广播服务可以接收，并处理用户请求连接的响应。没有回调，会弹出默认的提示框，并处理连接。 6. MCBrowserViewController //用于搜索附近的用户，是基于MCNearbyServiceBrowse的封装 使用步骤 MCPeerID，MCSession，MCNearbyServiceAdvertiser，MCNearbyServiceBrowser本文中用这四个类来实现（MCNearbyServiceAdvertiser，MCNearbyServiceBrowserx相对来说更原生态，此处通过这个两个类来编写代码更容易帮助我们理解其内部实现的过程）。 通过MCPeer来生成节点信息 通过MCNearbyServiceAdvertiser来发送广播，告诉别人这里有个节点可连接，其他节点想要发现此节点必须 通过MCNearbyServiceBrowser来搜索服务（标示符）来找到发送广播的节点，并请求连接，当连接成功后便可以通过MCSession来进行消息的发送和读取。 代码部分123456789101112//需要遵循以下协议@interface MultiPeerModule : NSObject&lt;MCSessionDelegate,MCBrowserViewControllerDelegate&gt;@property(nonatomic,strong)MCPeerID *peerID; //PeerID-&gt;连接设备的标志@property(nonatomic,strong)MCSession *mySession; //会话-&gt;用于传输数据@property(nonatomic,strong)MCBrowserViewController *browser; //系统基于MCNearbyServiceBrowser 封装的一个Controller@property(nonatomic,strong)MCAdvertiserAssistant *advertiser; //广播-&gt;用于向外发送服务，让Browser搜索到开了广播的设备@end ####初始化 123456789101112131415161718_peerID = [[MCPeerID alloc]initWithDisplayName:[UIDevice currentDevice].name];_mySession = [[MCSession alloc]initWithPeer:_peerID];_mySession.delegate = self; //它是由ASCII字母、数字和“-”组成的短文本串，最多15个字符。通常，一个服务的名字应该由应用程序的名字开始，后边跟“-”和一个独特的描述符号。_browser = [[MCBrowserViewController alloc]initWithServiceType:@\"trans-stream\" session:_mySession];_browser.delegate = self; //初始化广播_advertiser = [[MCAdvertiserAssistant alloc]initWithServiceType:@\"trans-stream\" discoveryInfo:nil session:_mySession];//这是开始广播方法,向四周发送广播//[_advertiser start];//同理Stop//[_advertiser stop]; ####代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//连接状态更改//无论服务端和客户端//只要连接状态改变，都会进入这个代理//PS:好像无法获得是服务端还是客户端变化?-(void)session:(MCSession *)session peer:(MCPeerID *)peerID didChangeState:(MCSessionState)state&#123; switch (state) &#123; case MCSessionStateConnected: NSLog(@\"Connected With %@ Success!\",peerID.displayName); //连接成功后发送通知 //做后续逻辑 [[NSNotificationCenter defaultCenter]postNotificationName:@\"SuccessConnect\" object:peerID]; break; case MCSessionStateConnecting: NSLog(@\"Connecting With %@ =================&gt;\",peerID.displayName); break; case MCSessionStateNotConnected: NSLog(@\"Lost Connected With %@ Bye~!\",peerID.displayName); [[NSNotificationCenter defaultCenter]postNotificationName:@\"LostConnect\" object:peerID]; break; default: NSLog(@\"Unknown Error=======&gt;\"); break; &#125;&#125;//第一个方法在节点改变状态的时候被调用，已连接或已断开。//有三个状态： MCSessionStateConnected , MCSessionStateConnecting and MCSessionStateNotConnected。最后一个状态在节点从连接断开后依然有效。//第二个方法在有新数据从节点过来时被调用。//记住有三种数据可以交换：消息，流和资源。这个是消息的代理。-(void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123; if (data.length&gt;0) &#123; NSLog(@\"收到的Data长度:%ld\",data.length); [[NSNotificationCenter defaultCenter] postNotificationName:@\"didReceiveData\" object:data]; &#125; &#125;-(void)session:(MCSession *)session didStartReceivingResourceWithName:(NSString *)resourceName fromPeer:(MCPeerID *)peerID withProgress:(NSProgress *)progress&#123; &#125;-(void)session:(MCSession *)session didReceiveStream:(NSInputStream *)stream withName:(NSString *)streamName fromPeer:(MCPeerID *)peerID&#123; &#125;-(void)session:(MCSession *)session didFinishReceivingResourceWithName:(NSString *)resourceName fromPeer:(MCPeerID *)peerID atURL:(NSURL *)localURL withError:(NSError *)error&#123; &#125;//选择设备系统自定义Controller-(void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController&#123; [self.browser dismissViewControllerAnimated:YES completion:nil];&#125;-(void)browserViewControllerWasCancelled:(MCBrowserViewController *)browserViewController&#123; [self.browser dismissViewControllerAnimated:YES completion:nil];&#125; 以上就是 Multipeer connectivity 需要实现的代理方法使用略","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]},{"title":"Pod私有库素材管理","date":"2019-09-24T07:31:27.131Z","path":"2019/09/24/PodResourceUsage/","text":"​ 首先说说场景,由于以前项目是基于小组件化功能开发最后再拼合起来。某一些模块内需要用到一些UI素材，做法就是在 .podspec中的 resource_bundle中添加素材的路径,执行 pod install后添加到pod里面 12345s.resource_bundles = &#123; #素材路径 #采用的是keyValue形式 &apos;Bundle名字&apos; =&gt; [&apos;路径/Resource/Asset/**/**.png&apos;] &#125; 如上，pod install时候就会在路径文件夹下，导入所有.png素材到工程里面. 这是网上普遍做法，且 cocoapod 的 .podspec 文件中也是默认这样导进去素材的.这样导进素材有什么问题呢? install完，素材只是简单的copy到了项目bundle里面(PS:素材文件夹命名也不正规)。会有以下问题: 管理起来麻烦 如果图片资源放到 .xcasset 里面 Xcode 会帮我们自动优化、可以使用 Slicing 等，但是放在 bundle里面并不会压缩素材等，等项目大了，包越来越大 所以，调研了网上做法，踩了坑之后决定写一篇文章记录下做法，这也是 包瘦身 一个方法.由于从0记录了整个过程，我会从创建私有库开始写起，如果你已经有了私有库，直接可以跳去第二步看起 1. 创建私有库使用pod lib create 私有库名字 创建完之后会自动打开工程 2.资源文件引用的方式 CocoaPods 两种资源文件引用的方式——resource_bundles &amp; resources 2.1 resources在 .podspec 利用 resources 属性可以指定 pod 要使用的资源文件。这些资源文件在 build 时会被直接拷贝到 client target 的 mainBundle 里。这样就实现了把图片、音频、NIB等资源打包进最终应用程序的目的。 但是，这就带来了一个问题，那就是 client target 的资源和各种 pod 所带来的资源都在同一 bundle 的同一层目录下，很容易产生命名冲突。 例如，我的 app 里有张按钮图片叫 “button.png”，而你的 pod 里也有张图片叫 “button.png”，拷贝资源时，我很担心 pod 里的文件会不会把我 app 里的同名文件给覆盖掉？即使没覆盖掉，程序运行时到底用哪张？很显然，我们不希望上述事情发生。 2.2 resource_bundlesresource_bundles 允许定义当前 Pod 库的资源包的名称和文件。用 hash 的形式来声明，key 是 bundle 的名称，value 是需要包括的文件的通配 patterns。 为了解决上述问题，CocoaPods 在 0.23.0 加入了一个新属性 resource_bundles。示例用法如下： 1234spec.resource_bundles = &#123; 'MyLibrary' =&gt; ['Resources/*.png'], 'OtherResources' =&gt; ['OtherResources/*.png']&#125; 可见， resources 和 resource_bundles 的差别是在于后者用字典替换了数组。相较之前所有资源都平铺开来的做法，新属性显式地做了 bundle 层面的分组。有组织、有纪律！CocoaPods 官方显然更推荐 resource_bundles。原因有二： 如前所述，用 resources 属性容易引起资源的命名冲突。诚然， resource_bundles 也有极小的可能在 bundle 名上起冲突，可那也比前者好处理。 用 resources 属性指定的资源直接被拷贝到 client target（事实上 CocoaPods 会先运行脚本对 NIB，Asset Catalog，Core Data Model 等进行编译） 2.3 Assets.xcassetsAssets.xcassets是用来存放图像资源文件的。常常利用Assets.xcassets来管理项目中用到的icon和各种图片素材, 但其除了提供为不同设备和Size Classes添加不同的图片这种基础使用方式,这个也不做过多解释，我们的目标就是将Pod里面的素材打包生成这样东西 3.Pod私有库素材管理调查得到上面结果，我们目标与技术选择也很明白了，选择resource_bundles + Assets.xcassets 方式管理 Pod 里面的素材就ok了 做这个之前，我们还是测试下使用 resources + Assets.xcassets 会有什么坑吧 3.1 resources + Assets.xcassets 方式首先在刚创建的私有库 .podspec 中配置一下 素材路径这里不用 cocoapod 默认的 resource_bundles,改为resource形式读取素材，素材路径为 pod私有库下Assets文件夹里面所有的 *.xcassets文件。此时我们在 Assets 中创建2个 xcassets测试下读取情况 分别再每个module中创建各自的 xcassets,名字与文件夹名字一样. 创建完之后再 Example文件夹中运行pod install更新下文件结构 完成后我们手动add file导入刚刚创建的2个 *.xcassets 并向里面添加图片测试(图片名字先不要一样测试) 我们在 submodule1.xcassets 中添加了两个素材 loading@2x 与 loading@3x ; submodule2.xcassets 中添加2个素材 arrow@2x、arrow@3x, install 一下 可见，素材 .xcassets 已经导入成功且里面也有相应素材.然后读取相应素材 这种使用 resource方法处理 pod 文件需要用以下方法读取图片 1234//当然这个图片也可以用 submodule2 里面的图片名字，仅做测试 NSBundle *bundle = [NSBundle bundleForClass:[self class]]; UIImage *image = [UIImage imageNamed:@&quot;loading&quot; inBundle:bundle compatibleWithTraitCollection:nil]; self.imageView.image = image; 为什么需要这种方法读取呢 由于 iOS 8 Dynamic Frameworks 特性的引入，CocoaPods 能帮你打包 framework 了。0.36 版的 release note很详细地说明了加入 framework 特性所带来的变化。一个显著区别就是当你的 pod 库以 framework 形式被使用时，你的资源不是被拷贝到 mainBundle 下，而是被放到 pod 的最终产物—— framework里。此时，你必须保证自己在访问这个 framework 的 bundle，而不是 client target 的。 1[NSBundle bundleForClass:&lt;#ClassFromPodspec#&gt;] 到此，我们成功的使用 resource 方法继承了 Pod中的素材，现在我们来测试下如果 *.xcassets 中如果有重复名字图片会怎么样 3.1.1 resource中 *.xcassets 中存在相同素材名字首先我们将重复名字的 loading 素材放进去 submodule2.xcassets中,因为 submodules2.xcassets 中的素材名字叫 arrow,如下图 install 一下，即会出现以下错误，重复 image sets,但是 Demo 中显示的图片还是原来的(submodule1.xcassets 的loading素材) loading素材， 此时我们会想是否编译顺序会影响素材读取,同理，我们重新添加一份素材名为arrow的素材放到 submodule1.xassets中，且在Demo中读取 arrow,不添加之前读取arrow是显示一个箭头素材的，这次看看添加一个同名的素材到submodule1.xassets中会出现什么情况 install 一下，同理提示错误 此时显示的素材为 submodule1.xcassets 中的 arrow 素材了. 3.1.2 resource中 .xcassets 中与项目本身的 .xcasset 存在相同素材名字然后我们试验下第二个问题，如果 Pod中的 *.xcasset 与项目自己的 *.xcasset 中素材重复名字会怎么样 此时我们先删除 submodule1.xcasset 中 arrow 素材，将其添加到 项目本身的 *.xcasset 中 经过测试，并不会有影响，因为在 Pod 中读取的是 Pod Bundle 中的素材，与App自身的 Asset是不会有影响的 由此我们得出使用 resource 的结论，如果 Pod Bundle中存在相同名字的素材，根据编译顺序不同，读取的图片不同。 3.2 resource_bundles准备工作如之前步骤一样，.podspec中可以写成如下: 此时改成了使用 s.resource_budnles，install 完项目结构如下: 同理在不同的 *.xcassets中放入不同素材,读取 此处读取图片需要硬编码方式读取, 加上了 bundle的路径,这样也是能正常加载出来的 此时我们也来测试下重复素材会怎么样,测试方法也是如上. 此时也会出现重复素材问题,为什么呢? 因为这个这个方法： 123s.resource_bundles = &#123; &apos;Pod-Resource&apos; =&gt; [&apos;Pod-Resource/Assets/**/*.xcassets&apos;]&#125; 将Assets里面的所有素材最后都打包到 bundle里面，遇到重复的名字的素材也会有上面问题，所以我们稍微改下上面的写法，改成: 12345s.resource_bundles = &#123;#不同文件夹不同bundle打包 &apos;Pod-Resource1&apos; =&gt; [&apos;Pod-Resource/Assets/submodule1/*.xcassets&apos;], &apos;Pod-Resource2&apos; =&gt; [&apos;Pod-Resource/Assets/submodule2/*.xcassets&apos;], &#125; install完出现2个bundle 那么我们的做法其实就在读取图片时候，把硬编码改成相应的bundle即可 这个就能避免重复名字素材名字问题，当然这个硬编码也是其中一个不方便的缺点了 4 利用特性对项目的扩展上面研究了这么多，功能只局限于当前 pod 的素材管理，那么我们回到项目改动上做一些扩展. 项目来说需要将这个pod，嵌入到不同app里面，不同app素材用一套，是不是听起来做法有点熟悉， 是的我们可以根据不同项目，将这个 s.resource_bundles 重写,例如: 123456789101112//Bundle这个Key名字写死，方便在硬编码时候用相同的s.subspec &apos;aApp&apos; do |aApp| aApp.resource_bundles = &#123; &apos;Bundle&apos; =&gt; [&apos;aApp素材路径&apos;] &#125;ends.subspec &apos;bApp&apos; do |bApp| bApp.resource_bundles = &#123; &apos;Bundle&apos; =&gt; [&apos;bApp素材路径&apos;] &#125;end 如图，我们可以利用 cocoapod中的 Ruby脚本命令重写这个私有库对于不同 App 使用的不同素材.、 在硬编码中读取 Bundle 的路径即可 总结在这次调研中研究了 私有库 cocoapod一些使用与素材管理，包优化素材策略 resource_bundles 优点： 可以使用 .xcassets 指定资源文件 可以避免每个库和主工程之间的同名资源冲突 resource_bundles 缺点： 获取图片时可能需要使用硬编码的形式来获取：[[NSBundle bundleForClass:[self class]].resourcePath stringByAppendingPathComponent:@&quot;/SubModule_Use_Bundle.bundle&quot;] resources 优点： 可以使用 .xcassets 指定资源文件 resources 缺点： 会导致每个库和主工程之间的同名资源冲突 不需要用硬编码方式获取图片：[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]; So，一般来说使用 resource_bundles 会更好，不过关于硬编码，还可以再找找别的方式去避免。 最后为了不同App素材可以根据 Ruby 脚本写下 Bundle路径读取不同素材 最后上 Demo Reference1.关于 Pod 库的资源引用 resource_bundles or resources 2.给 Pod 添加资源文件 3.Pod 中资源引入方式对比","tags":[{"name":"iOS","slug":"iOS","permalink":"https://swlfigo.github.io/tags/iOS/"}]}]