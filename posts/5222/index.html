<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>高性能iOS应用开发 - Nevermore</title><meta description="最近读《高性能iOS应用开发》一书，重新了解了下iOS中内存模型与一些开发中注意事项，并摘抄书中知识点做了下笔记，另外原来不了解方面知识也做了相关资料搜索作笔记补充。（如有错误欢迎指正）  一. 开始1. 移动应用的性能1.1 定义性能性能是非常模糊的术语,高性能有着多重的含义和丰富的解释方式。（需要测量和监控的）性能指标是其中的 一个关注点，（实际上收集数据的）测量是另一个关注点。 1.2 性能"><meta property="og:type" content="blog"><meta property="og:title" content="高性能iOS应用开发"><meta property="og:url" content="https://swlfigo.github.io/posts/5222/"><meta property="og:site_name" content="Nevermore"><meta property="og:description" content="最近读《高性能iOS应用开发》一书，重新了解了下iOS中内存模型与一些开发中注意事项，并摘抄书中知识点做了下笔记，另外原来不了解方面知识也做了相关资料搜索作笔记补充。（如有错误欢迎指正）  一. 开始1. 移动应用的性能1.1 定义性能性能是非常模糊的术语,高性能有着多重的含义和丰富的解释方式。（需要测量和监控的）性能指标是其中的 一个关注点，（实际上收集数据的）测量是另一个关注点。 1.2 性能"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080557.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080626.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080643.jpg"><meta property="og:image" content="https://swlfigo.github.io/posts/5222/media/15371688148453.jpg"><meta property="og:image" content="https://swlfigo.github.io/posts/5222/media/15371694923367.jpg"><meta property="article:published_time" content="2019-04-28T10:49:01.000Z"><meta property="article:modified_time" content="2021-04-12T10:15:44.841Z"><meta property="article:author" content="Sylar"><meta property="article:tag" content="iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080557.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://swlfigo.github.io/posts/5222/"},"headline":"Nevermore","image":["http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080557.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080626.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080643.jpg","https://swlfigo.github.io/posts/5222/media/15371688148453.jpg","https://swlfigo.github.io/posts/5222/media/15371694923367.jpg"],"datePublished":"2019-04-28T10:49:01.000Z","dateModified":"2021-04-12T10:15:44.841Z","author":{"@type":"Person","name":"Sylar"},"description":"最近读《高性能iOS应用开发》一书，重新了解了下iOS中内存模型与一些开发中注意事项，并摘抄书中知识点做了下笔记，另外原来不了解方面知识也做了相关资料搜索作笔记补充。（如有错误欢迎指正）  一. 开始1. 移动应用的性能1.1 定义性能性能是非常模糊的术语,高性能有着多重的含义和丰富的解释方式。（需要测量和监控的）性能指标是其中的 一个关注点，（实际上收集数据的）测量是另一个关注点。 1.2 性能"}</script><link rel="canonical" href="https://swlfigo.github.io/posts/5222/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Nevermore" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-28T10:49:01.000Z" title="2019-04-28T10:49:01.000Z">2019-04-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-12T10:15:44.841Z" title="2021-04-12T10:15:44.841Z">2021-04-12</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">an hour read (About 7946 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">高性能iOS应用开发</h1><div class="content"><p>最近读《高性能iOS应用开发》一书，重新了解了下iOS中内存模型与一些开发中注意事项，并摘抄书中知识点做了下笔记，另外原来不了解方面知识也做了相关资料搜索作笔记补充。<strong>（如有错误欢迎指正）</strong></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080557.jpg"></p>
<h1 id="一-开始"><a href="#一-开始" class="headerlink" title="一. 开始"></a>一. 开始</h1><h2 id="1-移动应用的性能"><a href="#1-移动应用的性能" class="headerlink" title="1. 移动应用的性能"></a>1. 移动应用的性能</h2><h2 id="1-1-定义性能"><a href="#1-1-定义性能" class="headerlink" title="1.1 定义性能"></a>1.1 定义性能</h2><p>性能是非常模糊的术语,高性能有着多重的含义和丰富的解释方式。（需要测量和监控的）性能指标是其中的 一个关注点，（实际上收集数据的）测量是另一个关注点。</p>
<h2 id="1-2-性能指标"><a href="#1-2-性能指标" class="headerlink" title="1.2 性能指标"></a>1.2 性能指标</h2><p>性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。</p>
<h3 id="1-2-1-内存"><a href="#1-2-1-内存" class="headerlink" title="1.2.1 内存"></a>1.2.1 内存</h3><p>内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。<br>同时还要确保没有泄漏内存。随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。</p>
<h3 id="1-2-2-电量消耗"><a href="#1-2-2-电量消耗" class="headerlink" title="1.2.2 电量消耗"></a>1.2.2 电量消耗</h3><p>电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件。除了要实现电量消耗最小化，还要确保不会影响用户体验。</p>
<h3 id="1-2-3-初始化时间"><a href="#1-2-3-初始化时间" class="headerlink" title="1.2.3 初始化时间"></a>1.2.3 初始化时间</h3><p>应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。 刚好够用是一个开放式用语——<strong>正确的平衡点取 决于应用的需要。</strong></p>
<h3 id="1-2-4-执行速度"><a href="#1-2-4-执行速度" class="headerlink" title="1.2.4 执行速度"></a>1.2.4 执行速度</h3><p>一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。</p>
<h3 id="1-2-5-响应速度"><a href="#1-2-5-响应速度" class="headerlink" title="1.2.5 响应速度"></a>1.2.5 响应速度</h3><p>每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。</p>
<h3 id="1-2-6-本地存储"><a href="#1-2-6-本地存储" class="headerlink" title="1.2.6 本地存储"></a>1.2.6 本地存储</h3><p>针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。<strong>如果你的应用使用了本地存储，那么请提供一个清除数据的选项。</strong></p>
<h3 id="1-2-7-互操作性"><a href="#1-2-7-互操作性" class="headerlink" title="1.2.7 互操作性"></a>1.2.7 互操作性</h3><p>用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。</p>
<h3 id="1-2-8-网络环境"><a href="#1-2-8-网络环境" class="headerlink" title="1.2.8 网络环境"></a>1.2.8 网络环境</h3><p>移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件：</p>
<ul>
<li><p>高带宽稳定网络</p>
</li>
<li><p>低带宽稳定网络</p>
</li>
<li><p>高带宽不稳定网络</p>
</li>
<li><p>低带宽不稳定网络</p>
</li>
<li><p>无网络</p>
</li>
</ul>
<h3 id="1-2-9-安全"><a href="#1-2-9-安全" class="headerlink" title="1.2.9 安全"></a>1.2.9 安全</h3><p>安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。<br>实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。</p>
 <a id="more"></a>

<h1 id="二-核心优化"><a href="#二-核心优化" class="headerlink" title="二. 核心优化"></a>二. 核心优化</h1><p>该部分讨论的优化包括以下方面:</p>
<ul>
<li><p>内存管理</p>
</li>
<li><p>能耗</p>
</li>
<li><p>并发编程</p>
</li>
</ul>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><p>与（基于垃圾回收的）Java 运行时不同， Objective-C 和 Swift 的 iOS 运行时使用引用计数。 使用引用计数的负面影响在于，如果开发人员不够小心，那么可能会出现重复的内存释放 和循环引用的情况。</p>
<h3 id="2-1-内存消耗"><a href="#2-1-内存消耗" class="headerlink" title="2.1 内存消耗"></a>2.1 内存消耗</h3><p>内存消耗指的是应用消耗的RAM。</p>
<p>iOS 的虚拟内存模型并不包含交换内存，与桌面应用不同，这意味着磁盘不会被用来分页 内存。最终的结果是应用只能使用有限的 RAM。 这些 RAM 的使用者不仅包括在前台运行 的应用，还包括操作系统服务，甚至还包括其他应用所执行的后台任务。</p>
<p>应用中的<strong>内存消耗分为两部分</strong>：<strong>栈大小</strong>和<strong>堆大小</strong>。</p>
<h4 id="2-1-1-栈大小"><a href="#2-1-1-栈大小" class="headerlink" title="2.1.1 栈大小"></a>2.1.1 栈大小</h4><p>应用中新创建的每个线程都有专用的栈空间， 该空间由保留的内存和初始提交的内存组成。线程的最大栈空间很小，这就决定了以下的限制。</p>
<ul>
<li>可被递归调用的最大方法数</li>
</ul>
<p>每个方法都有其自己的栈帧，并会消耗整体的栈空间。如果你调 用 main ，那么 main 将调用 method1 ，而 method1 又将调用 method2 ， 这就存在三个栈帧了，且每个栈帧都会消耗一定字节的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() &#123; </span><br><span class="line">    method1(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method1() &#123; </span><br><span class="line">    method2(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080626.jpg"></p>
<ul>
<li>一个方法中最多可以使用的变量个数</li>
</ul>
<p>所有的变量都会载入方法的栈帧中，并消耗一定的栈空间。</p>
<ul>
<li>视图层级中可以嵌入的最大视图深度</li>
</ul>
<p>渲染复合视图将在整个视图层级树中递归地调用 <code>layoutSubViews</code> 和 <code>drawRect</code> 方法。如果层级过深，可能会导致栈溢出。</p>
<h4 id="2-1-2-堆大小"><a href="#2-1-2-堆大小" class="headerlink" title="2.1.2 堆大小"></a>2.1.2 堆大小</h4><p>每个进程的所有线程共享同一个堆。使用 NSString 、载入图片、创建或使用 JSON/XML 数据、使用视图等都会消耗大量的堆 内存。<br>与通过类创建的对象相关的所有数据都存放在堆中。类可能包含属性或值类型的实例变量（iVars）， 如 int 、 char 或 struct 。但因为对象是在堆内创建的，所以它们只消耗堆内存。<br>当对象被创建并被赋值时，数据可能会从栈复制到堆。类似地， 当值仅在方法内部使用 时，它们也可能会被从堆复制到栈。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AClass</span>  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> anInteger; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *aString;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//一些其他的类 </span></span><br><span class="line">-(AClass *) createAClassWithInteger:(<span class="built_in">NSInteger</span>)i string:(<span class="built_in">NSString</span> *)s &#123; </span><br><span class="line">    AClass *result = [AClass new]; </span><br><span class="line">    result.anInteger = i; </span><br><span class="line">    result.aString = s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) someMethod:(<span class="built_in">NSArray</span> *)items &#123; </span><br><span class="line">    <span class="built_in">NSInteger</span> total = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">NSMutableString</span> *finalValue = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="keyword">for</span>(AClass *obj <span class="keyword">in</span> items) &#123; </span><br><span class="line">        total += obj.anInteger; </span><br><span class="line">        [finalValue appendString:obj.aString]; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下总结:</p>
<ul>
<li><strong>i 的值在栈上</strong>。但赋值给属性时，它必须被<strong>复制到堆</strong>中，因为那是存储 result 的地方。</li>
<li>虽然 NSString * 通过引用传递，但这个属性被标记为 copy 。这意味着它的值必须被复 制或克隆，这取决于 [-NSCopying copyWithZone:] 方法的实现。</li>
<li>使用 anInteger 时，它的值必须先<strong>复制到栈</strong>然后才能进行进一步的处理。在本示例中，它的值加到 total。</li>
</ul>
<h3 id="2-2-内存管理模型"><a href="#2-2-内存管理模型" class="headerlink" title="2.2 内存管理模型"></a>2.2 内存管理模型</h3><p>内存管理模型基于持有关系的概念。如果一个对象正处于被持有状态，那它占用的内存就 不能被回收。</p>
<p>一旦与某个对象相关的任务全部完成，那么就是放弃了持有关系。这一过程没有转移持有 关系，而是分别增加或减少了持有者的数量。当持有者的数量降为零时，对象会被释放。</p>
<p>这种持有关系计数通常被正式称为<strong>引用计数</strong>。</p>
<p><strong>eg.1</strong> 如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *message = <span class="string">@&quot;Objective-C is a verbose yet awesome language&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *messageRetained = [message <span class="keyword">retain</span>]; </span><br><span class="line">[messageRetained release]; </span><br><span class="line">[message release]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Value of message: %@&quot;</span>, message);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>创建对象、message 建立了持有关系，引用计数为 1。</li>
<li>messageRetained 建立了持有关系，引用计数增加为 2。</li>
<li>messageRetained 放弃了持有关系，引用计数降为 1。</li>
<li>message 放弃了持有关系，引用计数降为 0。</li>
<li>严格来讲，此时 message 的值是未定义的。你仍然能像之前那样得到相同的值，因为它 对应的内存还没有被回收或重置</li>
</ol>
<p><strong>eg.2</strong> 方法中的<strong>引用计数</strong>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//一个Person类的部分 </span></span><br><span class="line"><span class="comment">//注:此 NSString 创建方法相当不科学，可能作者为了例子这样写，我会在小结处再做进一步解释</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) address &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *result = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;%@\n%@\n%@, %@&quot;</span>, <span class="keyword">self</span>.line1, <span class="keyword">self</span>.line2, <span class="keyword">self</span>.city, <span class="keyword">self</span>.state];</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) showPerson:(Person *) p &#123; </span><br><span class="line">    <span class="built_in">NSString</span> *paddress = [p address];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person&#x27;s Address: %@&quot;</span>, paddress);</span><br><span class="line">    [paddress release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>首次创建对象，result 指向内存的引用计数为 1。 </li>
<li>通过 paddress （指向 result ）指向的内存的引用计数仍然是 1。 showPerson: 方法通过 address 按钮创建了对象，是对象的持有者。对象不应该被再次持有（ retain )。 </li>
<li>放弃持有关系；引用计数降为 0。</li>
</ol>
<h3 id="2-3-自动释放对象"><a href="#2-3-自动释放对象" class="headerlink" title="2.3 自动释放对象"></a>2.3 自动释放对象</h3><p>自动释放对象让你能够放弃对一个对象的持有关系，但延后对它的销毁。当在方法中创建 一个对象并需要将其返回时，自动释放就显得非常有用。自动释放可以帮助在 MRC 中管 理对象的生命周期。</p>
<p>在上面例子中，没什么能表示 address 方法持有了返回的字符串。因此，方法的调用者 showPerson: 也不应该释放返回的字符串，这可能会导致发生内存泄漏。加入 [paddress release] 这行代码的目的是为了指明这种情况。</p>
<p>以下是两种可能的解决方案。</p>
<ul>
<li><p>不要使用 alloc 或相关的方法。</p>
</li>
<li><p>对返回的对象使用延时释放。</p>
</li>
</ul>
<p>修改代码如下:</p>
<p><strong>eg.3</strong> 不要使用 alloc 或相关的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) address &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *result = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@\n%@\n%@, %@&quot;</span>, <span class="keyword">self</span>.line1, <span class="keyword">self</span>.line2, <span class="keyword">self</span>.city, <span class="keyword">self</span>.state]; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) showPerson:(Person *) p &#123; </span><br><span class="line">    <span class="built_in">NSString</span> *paddress = [p address];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person&#x27;s Address: %@&quot;</span>, paddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>不要使用 alloc 方法。 </li>
<li>由于 showPerson: 方法没有创建实体对象，因此不要在 showPerson: 方法中使用 release 方法。</li>
</ol>
<p>但是，当使用第三方类库或者某个类有多个用于创建对象的方法 时，到底是哪个方法保持了持有关系并不明确。所以引入了 <code>autorelease</code></p>
<p><strong>eg.4</strong>  autorelease</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) address &#123; </span><br><span class="line">    <span class="built_in">NSString</span> *result = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;%@\n%@\n%@, %@&quot;</span>, <span class="keyword">self</span>.line1, <span class="keyword">self</span>.line2, <span class="keyword">self</span>.city, <span class="keyword">self</span>.state] autorelease]; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>持有的对象（在上述示例中是 NSString ）是 alloc 方法返回的。</p>
</li>
<li><p>确保没有内存泄漏，你必须在失去引用之前放弃持有关系。</p>
</li>
<li><p>但是，如果使用了 release ,那么对象的释放将发生在返回之前，因而方法将返回一个 无效的引用。</p>
</li>
<li><p>autorelease 表明你想要放弃持有关系，同时允许方法的调用者在对象被释放之前使用对象。</p>
</li>
</ol>
<p><strong>结论如下:</strong></p>
<blockquote>
<p>当创建一个对象并将其从非 alloc 方法返回时，应使用 autorelease。 这样可以确保对象将被释放，并尽量在调用方法执行完成时立即释放。</p>
</blockquote>
<h3 id="2-4-自动释放池块-autoreleasepool"><a href="#2-4-自动释放池块-autoreleasepool" class="headerlink" title="2.4 自动释放池块 (@autoreleasepool)"></a>2.4 自动释放池块 (@autoreleasepool)</h3><p>自动释放池块是允许你放弃对一个对象的持有关系、但可避免它立即被回收的一个工具。它还能确保在块内创建的对象会在块完成时被回收。本地的块可以用来尽早地释放其中的对象，从而使内存用量保持在较低的水平。</p>
<p><code>main.m</code> 文件中的 <code>@autoreleasepool</code> 代码段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.m</span><br><span class="line">int main(int argc, char * argv[]) &#123; </span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([HPAppDelegate class])); </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;end</span><br></pre></td></tr></table></figure>


<p>那么，块中收到过 <code>autorelease</code> 消息的所有对象都会在 <code>autoreleasepool</code> 块结束时收到 release 消息</p>
<p>(<strong>注 : 根据一些网上一些文章解析, Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong> )</p>
<p>但在一些特定情况下，可能想创建自己的 <code>autoreleasepool</code> 块</p>
<ul>
<li>当你有一个创建了很多临时对象的循环时</li>
</ul>
<p>在循环中使用 autoreleasepool 块可以为每个迭代释放内存。虽然迭代前后最终的内存 使用相同，但你的应用的最大内存需求可以大大降低。</p>
<p><strong>eg.1</strong> 错误的 <code>autoreleasepool</code> 示范代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//错误代码示范</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> *userCount = userDatabase.userCount;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">NSUInteger</span> *i = <span class="number">0</span>; i &lt; userCount; i++)&#123; </span><br><span class="line">            Person *p = [userDatabase userAtIndex:i];</span><br><span class="line">            <span class="built_in">NSString</span> *fname = p.fname; </span><br><span class="line">            <span class="keyword">if</span>(fname == <span class="literal">nil</span>) &#123; </span><br><span class="line">                fname = [<span class="keyword">self</span> askUserForFirstName]; </span><br><span class="line">             &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *lname = p.lname; </span><br><span class="line">            <span class="keyword">if</span>(lname == <span class="literal">nil</span>) &#123; </span><br><span class="line">                lname = [<span class="keyword">self</span> askUserForLastName]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            [userDatabase updateUser:p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>eg.2</strong> 正确 <code>autoreleasepool</code> 示范:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> *userCount = userDatabase.userCount;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">NSUInteger</span> *i = <span class="number">0</span>; i &lt; userCount; i++)&#123; </span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                Person *p = [userDatabase userAtIndex:i];</span><br><span class="line">                <span class="built_in">NSString</span> *fname = p.fname; </span><br><span class="line">                <span class="keyword">if</span>(fname == <span class="literal">nil</span>) &#123; </span><br><span class="line">                    fname = [<span class="keyword">self</span> askUserForFirstName]; </span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="built_in">NSString</span> *lname = p.lname; </span><br><span class="line">                <span class="keyword">if</span>(lname == <span class="literal">nil</span>) &#123; </span><br><span class="line">                    lname = [<span class="keyword">self</span> askUserForLastName]; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                [userDatabase updateUser:p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>eg1中这段代码，因为只有一个 autoreleasepool ，而且内存清理工作要在所有的循环 迭代完成之后才能进行。</p>
</li>
<li><p>这个示例中有两个 autoreleasepool ，内层的 autoreleasepool 确保在每次循环迭代完成 后清理内存，从而导致更少的内存需求。</p>
</li>
</ol>
<h3 id="2-5-自动引用计数"><a href="#2-5-自动引用计数" class="headerlink" title="2.5 自动引用计数"></a>2.5 自动引用计数</h3><p>持续跟踪 retain 、 release 和 autorelease 并不容易。要想找出是谁在什么时间和地点向谁 发送了这些消息就更难了。<br>2011 年的全球开发者大会上介绍了解决这一问题的方案——<strong>ARC</strong>。<br><strong>ARC 是一种编译器特性。</strong> 它评估了对象在代码中的生命周期，并在编译时自动注入适合的 内存管理调用。<strong>编译器还会生成适合的 dealloc 方法。</strong></p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-080643.jpg"></p>
<h4 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h4><ol>
<li><p>不能实现或调用 retain 、 release 、 autorelease 或 retainCount 方法。 这一限制不仅针 对对象，对选择器同样有效。因此， [obj release] 或 @selector(retain) 是编译时的错误。</p>
</li>
<li><p>可以实现 dealloc 方法，但不能调用它们。不仅不能调用其他对象的 dealloc 方法，也不能调用超类。 [super dealloc] 是编译时的错误。 但你仍然可以对 Core Foundation 类型的对象调用 CFRetain 、 CFRelease 等相关方法。(注: CF 库需要手动内存管理)</p>
</li>
<li><p>不能调用 NSAllocateObject 和 NSDeallocateObject 方法。应使用alloc方法创建对象，运行时负责回收对象。</p>
</li>
<li><p>不能在 C 语言的结构体内使用对象指针。</p>
</li>
<li><p>不能在 id 类型和 void * 类型之间自动转换。如果需要，那么你必须做显示转换。</p>
</li>
<li><p>不能使用 NSAutoreleasePool ，要替换使用 autoreleasepool 块。</p>
</li>
<li><p>不能使用 NSZone 内存区域。</p>
</li>
<li><p>属性的访问器名称不能以 new 开头，以确保与 MRC 的互操作性。</p>
</li>
</ol>
<h3 id="2-6-引用类型"><a href="#2-6-引用类型" class="headerlink" title="2.6 引用类型"></a>2.6 引用类型</h3><p>ARC 带来了新的引用类型：<code>弱引用</code>。</p>
<ul>
<li><p>强引用<br>强引用是默认的引用类型。 被强引用指向的内存不会被释放。 强引用会对引用计数加 1， 从而扩展对象的生命周期。</p>
</li>
<li><p>弱引用<br>弱引用是一种特殊的引用类型。它不会增加引用计数，因而不会扩展对象的生命周期。</p>
</li>
</ul>
<h4 id="2-6-1-变量限定符"><a href="#2-6-1-变量限定符" class="headerlink" title="2.6.1 变量限定符"></a>2.6.1 变量限定符</h4><p>ARC 为变量供了<strong>四种生命周期限定符</strong>。</p>
<p>(注:由于书上内容解析不太深刻，找到个更好的解析)</p>
<table>
<thead>
<tr>
<th>Variable Qualifier</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>__strong</td>
<td>是默认的。只要有强类型指针指向一个对象，那么该对象会一直”生存“下去。</td>
</tr>
<tr>
<td>__weak<span class="Apple-tab-span" style="white-space:pre"></span></td>
<td>表明一个不会维持所持对象生命期的引用。当没有强引用指向该对象时，弱引用会设置为nil。</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>指定一个引用，该引用不会维持所持对象的生命期，并且在没有强引用指向对象时也不会设置为nil。如果它所指向的对象已经被释放，那么它会成为一个野指针。</td>
</tr>
<tr>
<td>__autoreleasing</td>
<td>用以指示以引用（id*）传入的参数并在retun后自动释放。</td>
</tr>
</tbody></table>
<p><strong>eg.1</strong> 使用变量限定符</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> Person * __<span class="keyword">strong</span> p1 = [[Person alloc] init];  </span><br><span class="line"><span class="number">2.</span> Person * __<span class="keyword">weak</span> p2 = [[Person alloc] init];</span><br><span class="line"><span class="number">3.</span> Person * __<span class="keyword">unsafe_unretained</span> p3 = [[Person alloc] init]; </span><br><span class="line"><span class="number">4.</span> Person * __autoreleasing p4 = [[Person alloc] init];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>创建对象后引用计数为 1， 并且对象在 p1 引用期间不会被回收。 </li>
<li>创建对象后引用计数为 0， 对象会被立即释放，且 p2 将被设置为 nil 。 </li>
<li>创建对象后引用计数为 1， 对象会被立即释放，但 p3 不会被设置为 nil 。 </li>
<li>创建对象后引用计数为 1， 当方法返回时对象会被立即释放。</li>
</ol>
<h3 id="2-7-僵尸对象"><a href="#2-7-僵尸对象" class="headerlink" title="2.7 僵尸对象"></a>2.7 僵尸对象</h3><p>僵尸对象是用于捕捉内存错误的调试功能。<br>通常情况下，当引用计数降为 0 时对象会立即被释放，但这使得调试变得困难。如果开启 了僵尸对象， 那么对象就不会立即释放内存， 而是被标记为僵尸。 任何试图对其进行访 问的行为都会被日志记录， 因而你可以在对象的生命周期中跟踪对象在代码中被使用的位置。</p>
<h3 id="2-9-循环引用"><a href="#2-9-循环引用" class="headerlink" title="2.9 循环引用"></a>2.9 循环引用</h3><p>(<strong>注: 书上的例子非常不科学，写出来是没有循环引用问题的。循环引用开发中比较常见，所以这里不做更多笔记说明。</strong>)</p>
<h3 id="Final-内存这块笔记小结"><a href="#Final-内存这块笔记小结" class="headerlink" title="Final 内存这块笔记小结:"></a>Final 内存这块笔记小结:</h3><p>读完内存模块这一章节了解到更多内存管理方面知识,有以下几点补充总结。</p>
<h4 id="1-iOS中一共有哪些存储空间："><a href="#1-iOS中一共有哪些存储空间：" class="headerlink" title="1. iOS中一共有哪些存储空间："></a>1. iOS中一共有哪些存储空间：</h4><ol>
<li>栈区（stack）</li>
<li>堆区（heap）</li>
<li>静态区</li>
<li>寄存器区</li>
<li>文字常量区</li>
<li>程序代码区</li>
</ol>
<h4 id="2-栈区"><a href="#2-栈区" class="headerlink" title="2. 栈区"></a>2. 栈区</h4><p>栈区中的内存空间是由编译器自动释放的，一般来是<strong>存放参数</strong>，<strong>局部变量</strong>等等。<br>在iOS开发中，栈空间的大小为1M。</p>
<h4 id="3-堆区"><a href="#3-堆区" class="headerlink" title="3. 堆区"></a>3. 堆区</h4><p>栈空间只有1M，那么我们很多时候需要的资源都会超过1M，所以由此也引出了堆。在iOS中，栈空间是每个程序都有一个的，而且互相不干扰，堆空间则是一个系统公共的，换句话说就是所有的应用程序都使用一个堆空间。<br>对于堆中的内存空间的操作，是通过链表来操作的</p>
<h4 id="4-MRC-stringWithFormat-和-initWithFormat-有何不同？"><a href="#4-MRC-stringWithFormat-和-initWithFormat-有何不同？" class="headerlink" title="4. (MRC) stringWithFormat 和 initWithFormat 有何不同？"></a>4. (MRC) stringWithFormat 和 initWithFormat 有何不同？</h4><ol>
<li>initWithFormat是实例方法</li>
</ol>
<p>只能经由过程 NSString* str = [[NSString alloc] initWithFormat:＠”％＠”，＠”Hello World”] 调用，然则必须<strong>手动release</strong>来开释内存资料</p>
<ol start="2">
<li>stringWithFormat是类方法</li>
</ol>
<p>可以直接用 NSString* str = [NSString stringWithFormat:＠”％＠”，＠”Hello World”] 调用，内存经管上是autorelease的，不需手动显式release</p>
<ol start="3">
<li>Example:</li>
</ol>
<p>别的国外有个贴子对此有专门评论辩论并且提出了一个常见错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">label.text &#x3D; [[NSString alloc] initWithFormat:＠&quot;％＠&quot;，＠&quot;abc&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在 <code>dealloc</code> 中将 <code>label</code>给 <code>release</code> 掉然则仍然会产生内存泄漏！</p>
<p>原因在于：用</p>
<p>label.text = …</p>
<p>时，实际是隐式调用的label的<code>setText</code>办法，这会<code>retain label</code>内部的字符串变量<code>text</code>（哪怕这个字符串的内容跟传进来的字符串内容雷同，但体系仍然当成二个不合的字符串对象），所以最后<code>release label</code>时，实际上只开释了label内部的text字符串，然则最初用<code>initWithFormat</code>生成的字符串并未开释，终极造成了泄漏。</p>
<p><strong>为什么会导致这样的情况呢？</strong></p>
<p><code>initWithString</code>申请的地址每次都是一样的，而<code>initWithFormat</code>的地址每次都不一样，这个说明什么？<br>说明<code>initWithString</code>的地址是静态的，而<code>initWithFormat</code>是动态的。</p>
<h4 id="5-autoreleasing"><a href="#5-autoreleasing" class="headerlink" title="5. __autoreleasing"></a>5. __autoreleasing</h4><p>有以下代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">//blablabla</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>error</code> 是隐式调用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> e;</span><br></pre></td></tr></table></figure>

<p>方法的声明通常是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)performOperationWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br></pre></td></tr></table></figure>

<p>因此编译器会重写代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> error;</span><br><span class="line"><span class="built_in">NSError</span> * __autoreleasing tmp = error;</span><br><span class="line"><span class="built_in">BOOL</span> OK = [myObject performOperationWithError:&amp;tmp];</span><br><span class="line">error = tmp;</span><br><span class="line"><span class="keyword">if</span> (!OK) &#123;</span><br><span class="line">    <span class="comment">//blablabla</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地变量声明( __strong)和参数( __autoreleasing)之间的区别导致编译器创建临时变量。在获取__strong变量的地址时你可以通过将参数声明为 id __storng*来获得其原始指针。或者你可以将变量声明为 __autoreleasing。</p>
<p><strong>问题:</strong></p>
<ol>
<li><code>-(BOOL)performOperationWithError:(NSError * __autoreleasing *)error;</code>中为什么需要用 <code>__autoreleasing</code> 变量限定符修饰？</li>
<li>本地变量声明<code>( __strong)</code>和参数<code>( __autoreleasing)</code>之间的区别导致编译器创建临时变量？</li>
</ol>
<p>解决上述两个问题，首先得知道:</p>
<ol>
<li>__autoreleasing是什么？</li>
<li>__autoreleasing作用什么？（为什么要使用__autoreleasing）</li>
</ol>
<h5 id="5-1-autoreleasing-是什么？"><a href="#5-1-autoreleasing-是什么？" class="headerlink" title="5.1 __autoreleasing 是什么？"></a>5.1 __autoreleasing 是什么？</h5><p>__autoreleasing 是 ARC 下用于控制变量生命周期而引入的4个变量限定符之一。</p>
<h5 id="5-2-autoreleasing-作用什么？（为什么要使用-autoreleasing"><a href="#5-2-autoreleasing-作用什么？（为什么要使用-autoreleasing" class="headerlink" title="5.2 __autoreleasing 作用什么？（为什么要使用__autoreleasing)?"></a>5.2 __autoreleasing 作用什么？（为什么要使用__autoreleasing)?</h5><p><strong>ARC:</strong></p>
<ol>
<li>不能显式的调用dealloc，实现或调用 retain， release， retainCount，或 autorelease。</li>
<li>不能使用 NSAutoreleasePool 对象<blockquote>
<p>ARC 提供了 @autoreleasepool来代替。这比 NSAutoreleasePool更高效。</p>
</blockquote>
</li>
</ol>
<p>对比一下 MRC 与 ARC 下使用 autoreleasepool 的不同地方：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MRC  */</span></span><br><span class="line"><span class="number">1</span> <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="number">2</span> <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="number">3</span> [obj autorelease]; <span class="comment">//对象调用 autorelease 方法就是将该对象注册到最近的 autoreleasepool 中</span></span><br><span class="line"><span class="number">4</span> [pool drain];</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ARC */</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="number">2</span>   <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过将对象赋值给带有 <code>__autoreleasing</code> 修饰符的变量来代替调用 <code>autorelease</code> 方法，即将对象注册到 <code>autoreleasepool</code></strong></p>
<p>所以:</p>
<p>被添加到autoreleasepool了，默认情况下要将 obj 指向的对象添加到autoreleasepool中是需要 __autoreleasing 修饰符去修饰 obj 的，那么ARC 下它应该就会进行一个编译转换，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __autoreleasing tem = obj;</span><br></pre></td></tr></table></figure>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nineteen_/article/details/48782465">https://blog.csdn.net/nineteen_/article/details/48782465</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.isaced.com/post-240.html">http://www.isaced.com/post-240.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/245bdcb47e3b">https://www.jianshu.com/p/245bdcb47e3b</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0258ed2133ff">https://www.jianshu.com/p/0258ed2133ff</a></p>
</li>
</ol>
<h2 id="3-能耗"><a href="#3-能耗" class="headerlink" title="3. 能耗"></a>3. 能耗</h2><p>(<strong>注:这部分没有太多可以做笔记的知识点，忽略</strong>)</p>
<h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><h3 id="4-1-线程"><a href="#4-1-线程" class="headerlink" title="4.1 线程"></a>4.1 线程</h3><p><strong>线程</strong>是运行时执行的一组指令序列。</p>
<p>每个进程至少应包含一个线程。在 iOS 中，进程启动时的主要线程通常被称作主线程。所 有的 UI 元素都需要在主线程中创建和管理。</p>
<p>Cocoa 编程不允许其他线程更新 UI 元素。这意味着，无论何时应用在后台线程执行了耗时 操作，比如网络或其他处理，代码都必须将上下文切换到主线程再更新 UI</p>
<h3 id="4-2-线程开销"><a href="#4-2-线程开销" class="headerlink" title="4.2 线程开销"></a>4.2 线程开销</h3><p>线程不仅仅有创建时的时间开销，还会消耗内核的内存，即应用的内存空间。</p>
<h4 id="4-2-1-内核数据结构"><a href="#4-2-1-内核数据结构" class="headerlink" title="4.2.1 内核数据结构"></a>4.2.1 内核数据结构</h4><p>每个线程大约消耗 1KB 的内核内存空间。这块内存用于存储与线程有关的数据结构和属 性。这块内存是联动内存（wired memory） ，无法被分页。</p>
<h4 id="4-2-2-栈空间"><a href="#4-2-2-栈空间" class="headerlink" title="4.2.2 栈空间"></a>4.2.2 栈空间</h4><p>主线程的栈空间大小为 1M， 而且<strong>无法修改</strong>。所有的二级线程默认分配 512KB 的栈空间。 注意，<strong>完整的栈并不会立即被创建出来</strong>。实际的<strong>栈空间大小会随着使用而增长</strong>。因此，即 使主线程有 1MB 的栈空间，某个时间点的实际栈空间很可能要小很多。</p>
<h3 id="4-3-GCD"><a href="#4-3-GCD" class="headerlink" title="4.3 GCD"></a>4.3 GCD</h3><p>GCD 提供的功能列表:</p>
<ul>
<li><p>任务或分发队列，允许主线程中的执行、并行执行和串行执行。</p>
</li>
<li><p>分发组，实现对一组任务执行情况的跟踪，而与这些任务所基于的队列无关。</p>
</li>
<li><p>信号量。</p>
</li>
<li><p>屏障，允许在并行分发队列中创建同步的点。</p>
</li>
<li><p>分发对象和管理源，实现更为底层的管理和监控。</p>
</li>
<li><p>异步 I/O， 使用文件描述符或管道。</p>
</li>
</ul>
<p>注意:<br>当应用中有多个长耗时的任 务需要并行执行时，最好 . 对线程的创建过程加以控制。如果代码执行的时间过长，很有可能达到<strong>线程的限制 64 个</strong>， 2,3 即 GCD 的线程池上限。</p>
<h3 id="4-4-操作与队列"><a href="#4-4-操作与队列" class="headerlink" title="4.4 操作与队列"></a>4.4 操作与队列</h3><p><code>NSOperation</code> 封装了一个任务以及和任务相关的数据和代码， 而 <code>NSOperationQueue</code> 以先入 先出的顺序控制了一个或多个这类任务的执行。 </p>
<p><code>NSOperation</code> 和 <code>NSOperationQueue</code> 都提供控制线程个数的能力。 可用 <code>maxConcurrentOperationCount</code> 属性控制队列的个数，也可以控制每个队列的线程个数。</p>
<p><strong>NSOperationQueue 和 GCD API 快速比较。</strong></p>
<ul>
<li><p>GCD</p>
<ul>
<li>抽象程度最高。</li>
<li>两种队列开箱即用： main 和 global 。</li>
<li>可以创建更多的队列（使用 dispatch_queue_create ）</li>
<li>可以请求独占访问（使用 dispatch_barrier_sync 和 dispatch_barrier_async ）。</li>
<li>基于线程管理。</li>
<li>硬性限制创建 64 个线程。</li>
</ul>
</li>
<li><p>NSOperationQueue</p>
<ul>
<li>无默认队列。</li>
<li>应用管理自己创建的队列。</li>
<li>队列是优先级队列。</li>
<li>操作可以有不同的优先级（使用 queuePriority 属性)。</li>
<li>使用 cancel 消息可以取消操作。注意， cancel 仅仅是个标记。 如果操作已经开始执行，则可能会继续执行下去。</li>
<li>可以等待某个操作执行完毕（使用 waitUntilFinished 消息）。</li>
</ul>
</li>
</ul>
<h3 id="4-5-线程安全的代码"><a href="#4-5-线程安全的代码" class="headerlink" title="4.5 线程安全的代码"></a>4.5 线程安全的代码</h3><p>书中讨论了 <code>atomic</code> 与 <code>nonatomic</code> 问题，与 <code>@synchronized</code> 的使用. 关于 <code>atomic</code> 与 <code>nonatomic</code> 是否绝对安全，一些面试题或者博客有更好的解释。</p>
<p>归纳知识点如下:</p>
<p>所有的属性默认都是原子性的。</p>
<p><code>atomic</code> 和 <code>nonatomic</code> 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。</p>
<p>对于<code>atomic</code>的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，<code>不受其他线程影响</code>。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。</p>
<p>而<code>nonatomic</code>就没有这个保证了。所以，<strong>nonatomic的速度要比atomic快</strong>。</p>
<p>不过<code>atomic</code>可<strong>并不能保证线程安全</strong>。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。</p>
<p>摘取 <strong>Mr.Peak</strong> 博客一个小结:</p>
<blockquote>
<p>atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p>
</blockquote>
<p><strong>原文:</strong> <a target="_blank" rel="noopener" href="http://mrpeak.cn/blog/ios-thread-safety/">传送门</a></p>
<p>另外文中还有一些锁的概念，这里也不做太多扩展.</p>
<h1 id="三-性能"><a href="#三-性能" class="headerlink" title="三. 性能"></a>三. 性能</h1><h2 id="5-应用生命周期"><a href="#5-应用生命周期" class="headerlink" title="5. 应用生命周期"></a>5. 应用生命周期</h2><p>iOS 应用启动时会调用 UIApplicationMain 方法，并传入 <code>UIApplicationDelegate</code> 类的引用。 委托接收应用范围的事件， 并且有明确的生命周期,<code>application:didFinishLaunchingWit hOptions:</code> 方法表明应用已经启动。关键组件的初始化就发生在这个方法中，如崩溃上报、</p>
<p>网络、日志以及埋点的初始化。此外，初次启动或恢复前置状态以便后续启动时，还可能会执行一些一次性的初始化操作。</p>
<h3 id="5-1-应用委托"><a href="#5-1-应用委托" class="headerlink" title="5.1 应用委托"></a>5.1 应用委托</h3><p>应用委托通常是应用创建的第一个对象。它为应用提供一些环境变量，其中包括应用启动 的详细信息、远程通知、深层链接，等等。</p>
<p>如图启动流程:</p>
<p><img src="media/15371688148453.jpg"></p>
<h3 id="5-2-应用启动"><a href="#5-2-应用启动" class="headerlink" title="5.2 应用启动"></a>5.2 应用启动</h3><p>著名的 <code>application:didFinishLaunchingWithOptions: </code>方法是应用启动时最核心的地方。此 处不能发生任何错误，且绝不能发生崩溃，否则应用将无法正常使用，直到下次升级。</p>
<p>应用有四种启动类型。</p>
<ul>
<li>首次启动</li>
</ul>
<p>安装应用后的首次启动。此时没有之前的状态，也没有本地缓存。</p>
<p>这意味着将会出现以下两种情况中的一种：没有需要加载的内容（因此加载时间会缩 短)，或者需要从服务器上下载初始数据（可能需要很长的加载时间）。</p>
<ul>
<li>冷启动 </li>
</ul>
<p>应用后续的启动。在启动期间，可能需要恢复原来的状态，例如，游戏中达到的最高等 级、消息应用中的聊天记录、新闻应用中上一次同步的文章、已登录用户的证书，或者 仅仅是用户已经使用过的引导图标记符。</p>
<ul>
<li>热(重)启动</li>
</ul>
<p>这是指当应用处于后台，但并未被挂起或关闭时，用户切换至应用而触发的启动。在这 种情况下，当用户通过点击应用图标或深层链接,返回应用时，不会触发 启动时的回调，而是直接用 <code>applicationDidBecomeActive: </code>（或 <code>application:openURL:so urce:annotation: </code>）回调。</p>
<ul>
<li>升级后启动</li>
</ul>
<p>应用升级以后的启动。通常而言，升级后的启动与冷启动没有差别。</p>
<h2 id="6-用户界面"><a href="#6-用户界面" class="headerlink" title="6. 用户界面"></a>6. 用户界面</h2><h3 id="6-1-视图控制器"><a href="#6-1-视图控制器" class="headerlink" title="6.1 视图控制器"></a>6.1 视图控制器</h3><p>视图控制器的生命周期。</p>
<p><img src="media/15371694923367.jpg"> </p>
<p>视图初始化时会涉及两个方法—— <code>loadView</code> 和 <code>viewDidLoad</code> 。当添加一个新的视图控制器时， 通过 Xcode 生成的模板代码只有 <code>viewDidLoad</code> 方法。当视图控制器的 <code>view</code> 被请求时， <code>loadView</code> 方法会被调用，但因为它还未被创建，所以会是 nil 。</p>
<p>视图会通过以下三种方式加载：</p>
<ul>
<li><p>从 nibs</p>
</li>
<li><p>使用故事板（使用 UIStoryboardSegue ）</p>
</li>
<li><p>使用自定义代码创建 UI</p>
</li>
</ul>
<p>如果通过覆写<code>loadView</code> 方法创建了自定义 UI，你需要牢记以下几点。</p>
<ul>
<li><p>将 view 属性设置到视图层级的根上。</p>
</li>
<li><p>确保视图正被其他的视图控制器所共享。</p>
</li>
<li><p><strong>不要调用 [super loadView]</strong> 。</p>
</li>
</ul>
<p>书上剩下的知识点比较常见，如 <code>TableView</code>，<code>UIWebView</code>介绍等，不做更多笔记.</p>
<h2 id="7-网络"><a href="#7-网络" class="headerlink" title="7 网络"></a>7 网络</h2><h2 id="8-数据共享"><a href="#8-数据共享" class="headerlink" title="8 数据共享"></a>8 数据共享</h2><h2 id="9-安全"><a href="#9-安全" class="headerlink" title="9 安全"></a>9 安全</h2><p>后续章节没有更多好的知识点，本书比较好的还是前半段关于内存知识点，更多知识点可以学习日本大佬写的那本 内存管理的书,看完这本书与另外搜索的笔记让一些模糊知识点变得清晰</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>高性能iOS应用开发</p><p><a href="https://swlfigo.github.io/posts/5222/">https://swlfigo.github.io/posts/5222/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Sylar</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2019-04-28</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-04-12</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/iOS/">iOS</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5e09772c1fb40b0012b7b886&amp;product=inline-share-buttons&amp;cms=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-12-30-032948.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/6244/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">iOS Extentsion 入门实战</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/5338/"><span class="level-item">YYCache阅读学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "qwfDlFFyjoqLxsvp6wMSrQrN-gzGzoHsz",
            appKey: "RTXYfbUeLWuXXJe9cjRX7fJC",
            placeholder: "Type something slowly...",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "en",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-25-032947.jpg" alt="Sylar"></figure><p class="title is-size-4 is-block line-height-inherit">Sylar</p><p class="is-size-6 is-block">一个不会iOS的搬砖工</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">30</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/swlfigo" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/sylar.su/"><i class="fab fa-instagram"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="http://roadmap.isylar.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS-RoadMap</span></span><span class="level-right"><span class="level-item tag">roadmap.isylar.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://tech.isylar.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Tech-Tips</span></span><span class="level-right"><span class="level-item tag">tech.isylar.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Hackintosh/"><span class="level-start"><span class="level-item">Hackintosh</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Metal/"><span class="level-start"><span class="level-item">Metal</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Note/"><span class="level-start"><span class="level-item">Note</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/iOS/ReactiveCocoa/"><span class="level-start"><span class="level-item">ReactiveCocoa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-12T10:09:02.000Z">2021-04-12</time></p><p class="title is-6"><a class="link-muted" href="/posts/undefined/">hackintoshEthernetProblem</a></p><p class="is-uppercase"></p></div></article><article class="media"><a class="media-left" href="/posts/2178376574/"><p class="image is-64x64"><img class="fill" src="/gallery/gcd-in-swift-thumbnail.jpeg" alt="gcd-in-swift"></p></a><div class="media-content size-small"><p><time dateTime="2020-09-21T09:15:48.000Z">2020-09-21</time></p><p class="title is-6"><a class="link-muted" href="/posts/2178376574/">gcd-in-swift</a></p><p class="is-uppercase"></p></div></article><article class="media"><a class="media-left" href="/posts/4106057131/"><p class="image is-64x64"><img class="fill" src="https://images.unsplash.com/photo-1581878811201-7d951612a47d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2134&amp;q=80" alt="bitcode"></p></a><div class="media-content size-small"><p><time dateTime="2020-02-16T11:31:55.000Z">2020-02-16</time></p><p class="title is-6"><a class="link-muted" href="/posts/4106057131/">bitcode</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/iOS/">iOS</a></p></div></article><article class="media"><a class="media-left" href="/posts/2261601169/"><p class="image is-64x64"><img class="fill" src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-02-05-135324.jpg" alt="iOS LaunchScreen 适配与缓存踩坑"></p></a><div class="media-content size-small"><p><time dateTime="2020-02-05T13:54:30.000Z">2020-02-05</time></p><p class="title is-6"><a class="link-muted" href="/posts/2261601169/">iOS LaunchScreen 适配与缓存踩坑</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/iOS/">iOS</a></p></div></article><article class="media"><a class="media-left" href="/posts/3684286012/"><p class="image is-64x64"><img class="fill" src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-12-30-092847.jpg" alt="iOS-NSDate"></p></a><div class="media-content size-small"><p><time dateTime="2019-11-19T06:39:15.000Z">2019-11-19</time></p><p class="title is-6"><a class="link-muted" href="/posts/3684286012/">iOS-NSDate</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hackintosh/"><span class="tag">Hackintosh</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Metal/"><span class="tag">Metal</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Note/"><span class="tag">Note</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReactiveCocoa/"><span class="tag">ReactiveCocoa</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">20</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Nevermore" height="28"></a><p class="size-small"><span>&copy; 2021 Sylar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Follow me on GitHub" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body></html>