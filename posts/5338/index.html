<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>YYCache阅读学习 - Nevermore</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Nevermore"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Nevermore"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="YYCache 阅读学习官网 介绍如下： 高性能 iOS 缓存框架。YYKit 组件之一。 性能:(摘自官网)iPhone 6 上，内存缓存每秒响应次数 (越高越好):   iPhone 6 上，磁盘缓存每秒响应次数 (越高越好):   特性 LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。 缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。"><meta property="og:type" content="blog"><meta property="og:title" content="YYCache阅读学习"><meta property="og:url" content="https://swlfigo.github.io/posts/5338/"><meta property="og:site_name" content="Nevermore"><meta property="og:description" content="YYCache 阅读学习官网 介绍如下： 高性能 iOS 缓存框架。YYKit 组件之一。 性能:(摘自官网)iPhone 6 上，内存缓存每秒响应次数 (越高越好):   iPhone 6 上，磁盘缓存每秒响应次数 (越高越好):   特性 LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。 缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081847.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081859.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081916.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081932.jpg"><meta property="og:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081948.jpg"><meta property="article:published_time" content="2019-04-28T10:49:01.000Z"><meta property="article:modified_time" content="2021-11-13T16:06:33.849Z"><meta property="article:author" content="Sylar"><meta property="article:tag" content="iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081847.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://swlfigo.github.io/posts/5338/"},"headline":"YYCache阅读学习","image":["http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081847.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081859.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081916.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081932.jpg","http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081948.jpg"],"datePublished":"2019-04-28T10:49:01.000Z","dateModified":"2021-11-13T16:06:33.849Z","author":{"@type":"Person","name":"Sylar"},"publisher":{"@type":"Organization","name":"Nevermore","logo":{"@type":"ImageObject","url":"https://swlfigo.github.io/img/logo.svg"}},"description":"YYCache 阅读学习官网 介绍如下： 高性能 iOS 缓存框架。YYKit 组件之一。 性能:(摘自官网)iPhone 6 上，内存缓存每秒响应次数 (越高越好):   iPhone 6 上，磁盘缓存每秒响应次数 (越高越好):   特性 LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。 缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。"}</script><link rel="canonical" href="https://swlfigo.github.io/posts/5338/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Nevermore" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-28T10:49:01.000Z" title="4/28/2019, 10:49:01 AM">2019-04-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-13T16:06:33.849Z" title="11/13/2021, 4:06:33 PM">2021-11-14</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">an hour read (About 11352 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">YYCache阅读学习</h1><div class="content"><h1 id="YYCache-阅读学习"><a href="#YYCache-阅读学习" class="headerlink" title="YYCache 阅读学习"></a>YYCache 阅读学习</h1><p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">官网</a> 介绍如下：</p>
<p>高性能 iOS 缓存框架。<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一。</p>
<h2 id="性能-摘自官网"><a href="#性能-摘自官网" class="headerlink" title="性能:(摘自官网)"></a>性能:(摘自官网)</h2><p>iPhone 6 上，内存缓存每秒响应次数 (越高越好): </p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081847.jpg" alt="test15169495589776"></p>
<p>iPhone 6 上，磁盘缓存每秒响应次数 (越高越好): </p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081859.jpg" alt="test15169495840565"></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>LRU: 缓存支持 LRU (least-recently-used) 淘汰算法。</li>
<li>缓存控制: 支持多种缓存控制方法：总数量、总大小、存活时间、空闲空间。</li>
<li>兼容性: API 基本和 NSCache 保持一致, 所有方法都是线程安全的。</li>
<li>内存缓存<ul>
<li>对象释放控制: 对象的释放(release) 可以配置为同步或异步进行，可以配置在主线程或后台线程进行。</li>
<li>自动清空: 当收到内存警告或 App 进入后台时，缓存可以配置为自动清空。</li>
</ul>
</li>
<li>磁盘缓存<ul>
<li>可定制性: 磁盘缓存支持自定义的归档解档方法，以支持那些没有实现 NSCoding 协议的对象。</li>
<li>存储类型控制: 磁盘缓存支持对每个对象的存储类型 (SQLite/文件) 进行自动或手动控制，以获得更高的存取性能。</li>
</ul>
</li>
</ul>
<a id="more"></a>


<h2 id="源码解析学习"><a href="#源码解析学习" class="headerlink" title="源码解析学习"></a>源码解析学习</h2><p>文中大部分为摘抄原文，然后加上自己的理解注释.</p>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>举一个缓存用户姓名的例子来看一下YYCache的几个API：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要缓存的对象</span></span><br><span class="line">   <span class="built_in">NSString</span> *userName = <span class="string">@&quot;Jack&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//需要缓存的对象在缓存里对应的键</span></span><br><span class="line">   <span class="built_in">NSString</span> *key = <span class="string">@&quot;user_name&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建一个YYCache实例:userInfoCache</span></span><br><span class="line">   YYCache *userInfoCache = [YYCache cacheWithName:<span class="string">@&quot;userInfo&quot;</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//存入键值对</span></span><br><span class="line">   [userInfoCache setObject:userName forKey:key withBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;caching object succeed&quot;</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//判断缓存是否存在</span></span><br><span class="line">   [userInfoCache containsObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="built_in">BOOL</span> contains) &#123;</span><br><span class="line">       <span class="keyword">if</span> (contains)&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;object exists&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据key读取数据</span></span><br><span class="line">   [userInfoCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;  _Nonnull object) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;user name : %@&quot;</span>,object);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据key移除缓存</span></span><br><span class="line">   [userInfoCache removeObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;remove user name %@&quot;</span>,key);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//移除所有缓存</span></span><br><span class="line">   [userInfoCache removeAllObjectsWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;removing all cache succeed&quot;</span>);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//移除所有缓存带进度</span></span><br><span class="line">   [userInfoCache removeAllObjectsWithProgressBlock:^(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;remove all cache objects: removedCount :%d  totalCount : %d&quot;</span>,removedCount,totalCount);</span><br><span class="line">   &#125; endBlock:^(<span class="built_in">BOOL</span> error) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;remove all cache objects: succeed&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;remove all cache objects: failed&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>



<h2 id="YYCache-整体结构"><a href="#YYCache-整体结构" class="headerlink" title="YYCache 整体结构"></a>YYCache 整体结构</h2><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081916.jpg" alt="test15169499260958"></p>
<ul>
<li>YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。</li>
<li>YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。</li>
<li>_YYLinkedMap：YYMemoryCache使用的双向链表类。</li>
<li>_YYLinkedMapNode：是_YYLinkedMap使用的节点类。</li>
<li>YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。</li>
<li>YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。</li>
<li>YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。</li>
</ul>
<h2 id="代码阅读学习"><a href="#代码阅读学习" class="headerlink" title="代码阅读学习"></a>代码阅读学习</h2><h3 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h3><p>YYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。</p>
<blockquote>
<p>因为YYMemoryCache和YYDiskCache的实例作为YYCache的两个公开的属性，所以用户无法直接使用YYMemoryCache和YYDiskCache对象，只能通过属性的方式来间接使用它们。</p>
</blockquote>
<h4 id="YYCache的属性和接口"><a href="#YYCache的属性和接口" class="headerlink" title="YYCache的属性和接口"></a>YYCache的属性和接口</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;<span class="comment">//缓存名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;<span class="comment">//内存缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;<span class="comment">//磁盘缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否包含某缓存，无回调</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//是否包含某缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓存对象，无回调</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//获取缓存对象，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//写入缓存对象，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某缓存，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//移除某缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有缓存，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"><span class="comment">//移除所有缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"><span class="comment">//移除所有缓存，有进度和完成的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="YYCache的接口实现"><a href="#YYCache的接口实现" class="headerlink" title="YYCache的接口实现"></a>YYCache的接口实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)containsObjectForKey:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;先检查内存缓存是否存在，再检查磁盘缓存是否存在</span><br><span class="line">    return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先尝试获取内存缓存，然后获取磁盘缓存</span><br><span class="line">    id&lt;NSCoding&gt; object &#x3D; [_memoryCache objectForKey:key];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil</span><br><span class="line">    if (!object) &#123;</span><br><span class="line">        object &#x3D; [_diskCache objectForKey:key];</span><br><span class="line">        if (object) &#123;</span><br><span class="line">            [_memoryCache setObject:object forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F;先写入内存缓存，后写入磁盘缓存</span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F;先移除内存缓存，后移除磁盘缓存</span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects &#123;</span><br><span class="line">    &#x2F;&#x2F;先全部移除内存缓存，后全部移除磁盘缓存</span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。</p>
<p><code>在读取缓存的操作中，如果在内存缓存中无法获取对应的缓存，则会去磁盘缓存中寻找。如果在磁盘缓存中找到了对应的缓存，则会将该对象再次写入内存缓存中，保证在下一次尝试获取同一缓存时能够在内存中就能返回，提高速度。</code></p>
<h3 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h3><h4 id="NSCache-内存缓存不足"><a href="#NSCache-内存缓存不足" class="headerlink" title="NSCache 内存缓存不足"></a>NSCache 内存缓存不足</h4><p>通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。相对于磁盘缓存来说，内存缓存的设计要更简单些，下面是我调查的一些常见的内存缓存。</p>
<p>NSCache 是苹果提供的一个简单的内存缓存，它有着和 NSDictionary 类似的 API，不同点是它是线程安全的，并且不会 retain key。我在测试时发现了它的几个特点：NSCache 底层并没有用 NSDictionary 等已有的类，而是直接调用了 libcache.dylib，其中线程安全是由 pthread_mutex 完成的。另外，它的性能和 key 的相似度有关，如果有大量相似的 key (比如 “1”, “2”, “3”, …)，NSCache 的存取性能会下降得非常厉害，大量的时间被消耗在 CFStringEqual() 上，不知这是不是 NSCache 本身设计的缺陷。</p>
<h4 id="YYMemoryCache-1"><a href="#YYMemoryCache-1" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h4><p>YYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。<br>但是与NSCache不同的是，YYMemoryCache的内部有：</p>
<ul>
<li>缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。</li>
<li>缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。</li>
</ul>
<p>一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下：<br>缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。<code>因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低。</code></p>
<p>缓存清理维度是给每个缓存添加的标记：</p>
<ul>
<li>如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。</li>
</ul>
<ul>
<li>如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</li>
</ul>
<ul>
<li>如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</li>
</ul>
<p>可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。<br>现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略：</p>
<h4 id="YYMemoryCache的缓存淘汰算法"><a href="#YYMemoryCache的缓存淘汰算法" class="headerlink" title="YYMemoryCache的缓存淘汰算法"></a>YYMemoryCache的缓存淘汰算法</h4><p><code>LRU算法</code></p>
<p>在YYMemoryCache中，使用了<code>双向链表</code>这个数据结构来保存这些缓存：</p>
<ul>
<li>当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>(根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。</li>
</ul>
<p>这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。</p>
<p>YYMemoryCach<code>e用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点。</code>这两个类的名称分别是：</p>
<ul>
<li>_YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。</li>
<li>_YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点)</li>
</ul>
<h4 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="_YYLinkedMapNode"></a>_YYLinkedMapNode</h4><p>_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="keyword">id</span> _key;              		  <span class="comment">//缓存key</span></span><br><span class="line">    <span class="keyword">id</span> _value;              	          <span class="comment">//key对应值</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost;                     <span class="comment">//缓存开销</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time;                 <span class="comment">//访问时间</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>双向链表类</code>:</p>
<h5 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; 	<span class="comment">// 用于存放节点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;   		<span class="comment">//总开销</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;  		<span class="comment">//节点总数</span></span><br><span class="line">    _YYLinkedMapNode *_head;            <span class="comment">// 链表的头部结点</span></span><br><span class="line">    _YYLinkedMapNode *_tail; 		<span class="comment">// 链表的尾部节点</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread; 	        <span class="comment">//是否在主线程释放，默认为NO</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously; 	<span class="comment">//是否在子线程释放，默认为YES</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在链表头部插入某节点</span></span><br><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将链表内部的某个节点移到链表头部</span></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个节点</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除链表的尾部节点并返回它</span></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有节点（默认在子线程操作）</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。</p>
<p>可以参考下面这张图来看一下二者的关系：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081932.jpg" alt="test15169551955682"></p>
<p><strong>PS:(阅读注)</strong></p>
<p><code>_YYLinkedMap</code> 类中有一个有一个字典记录着缓存对象信息,分别是 <code>Key</code> 与 <code>Node对象</code>, 包括了一个<code>头结点</code>与<code>尾节点</code>的 <code>Node</code>,形成了一个OC版链表,</p>
<p>_YYLinkedMap的接口的实现：<br>将节点插入到链表头部：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置该node的值</span></span><br><span class="line">    <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加开销和总缓存数量</span></span><br><span class="line">    _totalCost += node-&gt;_cost;</span><br><span class="line">    _totalCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_head) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点）</span></span><br><span class="line">        node-&gt;_next = _head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点）</span></span><br><span class="line">        _head-&gt;_prev = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该节点赋给链表的头结点指针（该节点变成了现第一个节点）</span></span><br><span class="line">        _head = node;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点</span></span><br><span class="line">        _head = _tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中：</p>
<ul>
<li>每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。</li>
<li>链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。</li>
</ul>
<p>为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们：<br>每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手；<br>而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。</p>
<p><strong>PS:(阅读注)</strong><br><code>C</code> 中的链表，头结点指向上一个节点的尾节点,尾节点指向下一个节点的头结点. 如果 插入时候，会判断缓存字典里面有没有数据，有的话，拿出来插到链表第一位，然后将原来位置的前后节点连接起来</p>
<p>将某个节点移动到链表头部：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果该节点已经是链表头部节点，则立即返回，不做任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (_head == node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_tail == node) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果该节点是链表的尾部节点</span></span><br><span class="line">        <span class="comment">//1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点）</span></span><br><span class="line">        _tail = node-&gt;_prev;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 将新的尾部节点的尾部指针置空</span></span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果该节点是链表头部和尾部以外的节点（中间节点）</span></span><br><span class="line">        <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点）</span></span><br><span class="line">    node-&gt;_next = _head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前节点的头节点置空</span></span><br><span class="line">    node-&gt;_prev = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点）</span></span><br><span class="line">    _head-&gt;_prev = node;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将该节点设置为链表的头节点</span></span><br><span class="line">    _head = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再结合链表的图解来看一下：</p>
<p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-081948.jpg" alt="test15169561271627"></p>
<p>移除链表中的某个节点：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//除去该node的键对应的值</span></span><br><span class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减去开销和总缓存数量</span></span><br><span class="line">    _totalCost -= node-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//节点操作</span></span><br><span class="line">    <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一）</span></span><br><span class="line">    <span class="keyword">if</span> (_head == node) _head = node-&gt;_next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一）</span></span><br><span class="line">    <span class="keyword">if</span> (_tail == node) _tail = node-&gt;_prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除并返回尾部的node:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果不存在尾节点，则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!_tail) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    _YYLinkedMapNode *tail = _tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除尾部节点对应的值</span></span><br><span class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(_tail-&gt;_key));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减少开销和总缓存数量</span></span><br><span class="line">    _totalCost -= _tail-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">        <span class="comment">//如果链表的头尾节点相同，说明链表只有一个节点。将其置空</span></span><br><span class="line">        _head = _tail = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一）</span></span><br><span class="line">        _tail = _tail-&gt;_prev;</span><br><span class="line">        <span class="comment">//将新的尾节点的尾指针置空</span></span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="YYMemoryCache的属性和接口"><a href="#YYMemoryCache的属性和接口" class="headerlink" title="YYMemoryCache的属性和接口"></a>YYMemoryCache的属性和接口</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存名称，默认为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存总数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存总开销</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Limit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数量上限，默认为NSUIntegerMax，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开销上限，默认为NSUIntegerMax，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存时间上限，默认为DBL_MAX，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理超出上限之外的缓存的操作间隔时间，默认为5s</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到内存警告时是否清理所有缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app进入后台是是否清理所有缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到内存警告的回调block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入后台的回调block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存清理是否在后台进行，默认为NO</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseOnMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存清理是否异步执行，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseAsynchronously;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Access Methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否包含某个缓存</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓存对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象，并添加对应的开销</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Trim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></span><br><span class="line"><span class="comment">//清理缓存到指定个数</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存到指定开销</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="YYMemoryCache的接口实现"><a href="#YYMemoryCache的接口实现" class="headerlink" title="YYMemoryCache的接口实现"></a>YYMemoryCache的接口实现</h5><p>在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">      ....</span><br><span class="line">      _lru = [_YYLinkedMap new];</span><br><span class="line">      ...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否包含某个缓存对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尝试从内置的字典中获得缓存对象</span></span><br><span class="line">  <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line">  <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">  <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个缓存对象</span></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line">  _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></span><br><span class="line">      node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">      [_lru bringNodeToHead:node];</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个缓存对象，开销默认为0</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">  [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个缓存对象，并存入缓存开销</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">      [<span class="keyword">self</span> removeObjectForKey:key];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line">  </span><br><span class="line">  _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">  <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">//如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//更新总cost</span></span><br><span class="line">      _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class="line">      _lru-&gt;_totalCost += cost;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//更新node</span></span><br><span class="line">      node-&gt;_cost = cost;</span><br><span class="line">      node-&gt;_time = now;</span><br><span class="line">      node-&gt;_value = object;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将node移动至链表头部</span></span><br><span class="line">      [_lru bringNodeToHead:node];</span><br><span class="line">      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部</span></span><br><span class="line">      <span class="comment">//新建node,并赋值</span></span><br><span class="line">      node = [_YYLinkedMapNode new];</span><br><span class="line">      node-&gt;_cost = cost;</span><br><span class="line">      node-&gt;_time = now;</span><br><span class="line">      node-&gt;_key = key;</span><br><span class="line">      node-&gt;_value = object;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将node插入至链表头部</span></span><br><span class="line">      [_lru insertNodeAtHead:node];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求）</span></span><br><span class="line">  <span class="keyword">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</span><br><span class="line">      <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">          [<span class="keyword">self</span> trimToCost:_costLimit];</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可）</span></span><br><span class="line">  <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</span><br><span class="line">      _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">      <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">          <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">          <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">              [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个缓存对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line">  _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//内部调用了链表的removeNode：方法</span></span><br><span class="line">      [_lru removeNode:node];</span><br><span class="line">      <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">          <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">          <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">              [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部调用了链表的removeAll方法</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line">  [_lru removeAll];</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。</p>
<h5 id="YYMemoryCache的缓存清理策略"><a href="#YYMemoryCache的缓存清理策略" class="headerlink" title="YYMemoryCache的缓存清理策略"></a>YYMemoryCache的缓存清理策略</h5><p>在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。</p>
<p><code>缓存自动清理</code></p>
<p>缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始定期清理</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimRecursively &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * <span class="built_in">NSEC_PER_SEC</span>)),</span><br><span class="line">                   </span><br><span class="line">        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">            </span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在后台进行清理操作</span></span><br><span class="line">        [<span class="keyword">self</span> _trimInBackground];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用自己，递归操作</span></span><br><span class="line">        [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">            </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理所有不符合限制的缓存，顺序为：cost，count，age</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimInBackground &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> _trimToCost:<span class="keyword">self</span>-&gt;_costLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToCount:<span class="keyword">self</span>-&gt;_countLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToAge:<span class="keyword">self</span>-&gt;_ageLimit];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCount:count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCost:cost];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToAge:age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。</p>
<h3 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h3><p>YYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是：</p>
<ul>
<li>都具有查询，写入，读取，删除缓存的接口。</li>
<li>不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。</li>
<li>它使用LRU算法来清理缓存。</li>
<li>支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。</li>
</ul>
<p>它与YYMemoryCache不同点是：</p>
<ul>
<li>根据缓存数据的大小来采取不同的形式的缓存：<ul>
<li>数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。</li>
<li>文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。</li>
<li>除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.h</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; _Nullable object))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCount;</span><br><span class="line">- (<span class="keyword">void</span>)totalCountWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCount))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCost;</span><br><span class="line">- (<span class="keyword">void</span>)totalCostWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCost))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它作为用sqlite做缓存还是用文件做缓存的分水岭：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</span><br></pre></td></tr></table></figure>

<p>这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">    <span class="built_in">NSString</span> *filename = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">        <span class="comment">//如果长度大临界值，则生成文件名称，使得filename不为nil</span></span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; _inlineThreshold) &#123;</span><br><span class="line">            filename = [<span class="keyword">self</span> _filenameForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Lock();</span><br><span class="line">    <span class="comment">//在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存</span></span><br><span class="line">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。<br>（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _kv = kv;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="built_in">BOOL</span> contains = [_kv itemExistsForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    [_kv removeItemForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h3><p>YYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVStorageItem.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">//键</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">//值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">//文件名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> size;                             <span class="comment">//值的大小，单位是byte</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> modTime;                          <span class="comment">//修改时间戳</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> accessTime;                       <span class="comment">//最后访问的时间戳</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">//extended data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>PS:阅读注</strong></p>
<p><code>YYKVStorageItem</code> 作为一个存储文件对象类，记录了文件信息，获取时候，从数据库读取文件信息，赋值然后返回</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVStorage.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">                  value:(<span class="built_in">NSData</span> *)value</span><br><span class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</span><br><span class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Remove Items</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个键的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除多个键的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除大于参数size的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsLargerThanSize:(<span class="keyword">int</span>)size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除时间早于参数时间的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsEarlierThanTime:(<span class="keyword">int</span>)time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除item，使得缓存总容量小于参数size</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitSize:(<span class="keyword">int</span>)maxSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除item，使得缓存数量小于参数size</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitCount:(<span class="keyword">int</span>)maxCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeAllItems;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有的item，附带进度与结束block</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllItemsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                               endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Get Items</span></span><br><span class="line"><span class="comment">//读取参数key对应的item</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数key对应的data</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getItemValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数数组对应的item数组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数数组对应的item字典</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSData</span> *&gt; *)getItemValueForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入某个item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">                  value:(<span class="built_in">NSData</span> *)value</span><br><span class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</span><br><span class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。</p>
<ol>
<li>首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。</li>
<li>再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。</li>
<li>判断filename是否为空字符串：</li>
<li>如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。</li>
<li>如果为空：</li>
<li>如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除</li>
<li>如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:key value:value filename:<span class="literal">nil</span> extendedData:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span> || value.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (filename.length) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名不为空字符串，说明要进行文件缓存</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写入元数据</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class="line">            <span class="comment">//如果缓存信息保存失败，则删除对应的文件</span></span><br><span class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名为空字符串，说明不要进行文件缓存</span></span><br><span class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果缓存类型不是数据库缓存，则查找出相应的文件名并删除</span></span><br><span class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存类型是数据库缓存，把元数据和value写入数据库</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  从上面的代码可以看出，在底层写入缓存的方法是<code>_dbSaveWithKey:value:fileName:extendedData:</code>，这个方法使用了两次:</p>
<ul>
<li>在以文件（和数据库）存储缓存时</li>
<li>在以数据库存储缓存时</li>
</ul>
<p>不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下_dbSaveWithKey:value:fileName:extendedData:内部是如何区分有无filename的情况的：</p>
<ul>
<li>当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里</li>
<li>当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库存储</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)_dbSaveWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value fileName:(<span class="built_in">NSString</span> *)fileName extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sql语句</span></span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@&quot;insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> timestamp = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//key</span></span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//filename</span></span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, fileName.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//size</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">3</span>, (<span class="keyword">int</span>)value.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//inline_data</span></span><br><span class="line">    <span class="keyword">if</span> (fileName.length == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名长度==0，则将value存入数据库</span></span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, value.bytes, (<span class="keyword">int</span>)value.length, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名长度不为0，则不将value存入数据库</span></span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//modification_time</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">5</span>, timestamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//last_access_time</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">6</span>, timestamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//extended_data</span></span><br><span class="line">    sqlite3_bind_blob(stmt, <span class="number">7</span>, extendedData.bytes, (<span class="keyword">int</span>)extendedData.length, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite insert error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 再来看一下获取缓存的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVSorage.m</span></span><br><span class="line">- (YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    YYKVStorageItem *item = [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">//更新内存访问的时间</span></span><br><span class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">            <span class="comment">//如果有文件名，则尝试获取文件数据</span></span><br><span class="line">            item.value = [<span class="keyword">self</span> _fileReadWithName:item.filename];</span><br><span class="line">            <span class="comment">//如果此时获取文件数据失败，则删除对应的item</span></span><br><span class="line">            <span class="keyword">if</span> (!item.value) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                item = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是_dbGetItemWithKey:excludeInlineData:<br>我们来看一下它的实现：</p>
<ul>
<li>首先根据查找key的sql语句生成stmt</li>
<li>然后将传入的key与该stmt进行绑定</li>
<li>最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (YYKVStorageItem *)_dbGetItemWithKey:(<span class="built_in">NSString</span> *)key excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = excludeInlineData ? <span class="string">@&quot;select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;&quot;</span> : <span class="string">@&quot;select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;&quot;</span>;</span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    YYKVStorageItem *item = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_ROW) &#123;</span><br><span class="line">        <span class="comment">//传入stmt来生成YYKVStorageItem实例</span></span><br><span class="line">        item = [<span class="keyword">self</span> _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite query error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终生成YYKVStorageItem实例的是通过<code>_dbGetItemFromStmt:excludeInlineData:</code>来实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提取数据</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *key = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</span><br><span class="line">    <span class="keyword">char</span> *filename = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</span><br><span class="line">    <span class="keyword">int</span> size = sqlite3_column_int(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断excludeInlineData</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *inline_data = excludeInlineData ? <span class="literal">NULL</span> : sqlite3_column_blob(stmt, i);</span><br><span class="line">    <span class="keyword">int</span> inline_data_bytes = excludeInlineData ? <span class="number">0</span> : sqlite3_column_bytes(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> modification_time = sqlite3_column_int(stmt, i++);</span><br><span class="line">    <span class="keyword">int</span> last_access_time = sqlite3_column_int(stmt, i++);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *extended_data = sqlite3_column_blob(stmt, i);</span><br><span class="line">    <span class="keyword">int</span> extended_data_bytes = sqlite3_column_bytes(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数据赋给item的属性</span></span><br><span class="line">    YYKVStorageItem *item = [YYKVStorageItem new];</span><br><span class="line">    <span class="keyword">if</span> (key) item.key = [<span class="built_in">NSString</span> stringWithUTF8String:key];</span><br><span class="line">    <span class="keyword">if</span> (filename &amp;&amp; *filename != <span class="number">0</span>) item.filename = [<span class="built_in">NSString</span> stringWithUTF8String:filename];</span><br><span class="line">    item.size = size;</span><br><span class="line">    <span class="keyword">if</span> (inline_data_bytes &gt; <span class="number">0</span> &amp;&amp; inline_data) item.value = [<span class="built_in">NSData</span> dataWithBytes:inline_data length:inline_data_bytes];</span><br><span class="line">    item.modTime = modification_time;</span><br><span class="line">    item.accessTime = last_access_time;</span><br><span class="line">    <span class="keyword">if</span> (extended_data_bytes &gt; <span class="number">0</span> &amp;&amp; extended_data) item.extendedData = [<span class="built_in">NSData</span> dataWithBytes:extended_data length:extended_data_bytes];</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这段代码分为两个部分：</p>
<ul>
<li>获取数据库里每一个字段对应的数据</li>
<li>将数据赋给YYKVStorageItem的实例</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>字符串类型需要使用stringWithUTF8String:来转成NSString类型。</li>
<li>这里面会判断excludeInlineData：</li>
</ol>
<ul>
<li>如果为TRUE，就提取存入的data数据</li>
<li>如果为FALSE，就不提取</li>
</ul>
<h3 id="保证线程安全的方案"><a href="#保证线程安全的方案" class="headerlink" title="保证线程安全的方案"></a>保证线程安全的方案</h3><p>对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的<br>由上文可以看出：</p>
<ul>
<li>YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全</li>
<li>YYDiskCache 则选择了更适合它的 dispatch_semaphore。</li>
</ul>
<h4 id="内存缓存操作的互斥锁"><a href="#内存缓存操作的互斥锁" class="headerlink" title="内存缓存操作的互斥锁"></a>内存缓存操作的互斥锁</h4><p>在YYMemoryCache中，是使用互斥锁来保证线程安全的。 首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)totalCost &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">NSUInteger</span> totalCost = _lru-&gt;_totalCost;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> totalCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setReleaseOnMainThread:(<span class="built_in">BOOL</span>)releaseOnMainThread &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _lru-&gt;_releaseOnMainThread = releaseOnMainThread;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而且需要在dealloc方法中销毁这个锁头：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="磁盘缓存使用信号量来代替锁"><a href="#磁盘缓存使用信号量来代替锁" class="headerlink" title="磁盘缓存使用信号量来代替锁"></a>磁盘缓存使用信号量来代替锁</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    ...</span><br><span class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.cache.disk&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后使用了宏来代替加锁解锁的代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Unlock() dispatch_semaphore_signal(self-&gt;_lock)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量:"></a>信号量:</h5><p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<ul>
<li>dispatch_semaphore_create：定义信号量</li>
<li>dispatch_semaphore_signal：使信号量+1</li>
<li>dispatch_semaphore_wait：使信号量-1</li>
</ul>
<p>当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：</p>
<ul>
<li>执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。</li>
<li>此时如果其他线程过来访问这段代码，就要让其等待。</li>
<li>当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。</li>
</ul>
<p>如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。</p>
<p>这也就是信号量和互斥锁的一个区别：<strong>互斥量用于线程的互斥，信号线用于线程的同步。</strong> </p>
<ul>
<li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。<strong>访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访</strong></p>
</li>
<li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p>
</li>
</ul>
<p><strong>PS:(互斥锁与信号量区别)</strong></p>
<p>“信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在 哪里）。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这 个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的”<br>也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务 并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进 行操作。在有些情况下两者可以互换。</p>
<p>更形象表达:</p>
<p>虽然 Mutex和Semaphore 在一定程度上可以互相替代，比如你可以把 值最大为1 的Semaphore当Mutex用，也可以用Mutex＋计数器当Semaphore。但是对于设计理念上还是有不同的，Mutex管理的是资源的使用权，而Semaphore管理的是资源的数量，有那么一点微妙的小区别。打个比方，在早餐餐厅，大家要喝咖啡。如果用Mutex的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。如果用Semaphore的模式，服务员会把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。</p>
<h5 id="使用锁思路"><a href="#使用锁思路" class="headerlink" title="使用锁思路"></a>使用锁思路</h5><p>为什么内存缓存使用互斥锁（pthread_mutex）？<br>框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。</p>
<p>为什么磁盘缓存使用的是信号量（dispatch_semaphore）？</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<p>因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。</p>
<h4 id="提高缓存性能的几个尝试"><a href="#提高缓存性能的几个尝试" class="headerlink" title="提高缓存性能的几个尝试"></a>提高缓存性能的几个尝试</h4><h5 id="选择合适的线程锁"><a href="#选择合适的线程锁" class="headerlink" title="选择合适的线程锁"></a>选择合适的线程锁</h5><p>如上所说</p>
<h5 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h5><p>在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？</p>
<ul>
<li>为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。</li>
<li>为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。</li>
</ul>
<h5 id="选择合适的线程来操作不同的任务"><a href="#选择合适的线程来操作不同的任务" class="headerlink" title="选择合适的线程来操作不同的任务"></a>选择合适的线程来操作不同的任务</h5><p>无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做：</p>
<p>看一下释放所有内存缓存的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAll &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将开销，缓存数量置为0</span></span><br><span class="line">    _totalCost = <span class="number">0</span>;</span><br><span class="line">    _totalCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将链表的头尾节点置空</span></span><br><span class="line">    _head = <span class="literal">nil</span>;</span><br><span class="line">    _tail = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CFDictionaryGetCount</span>(_dic) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</span><br><span class="line">        _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否在子线程操作</span></span><br><span class="line">        <span class="keyword">if</span> (_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数，返回优先级最低的全局并发队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="选择底层的类"><a href="#选择底层的类" class="headerlink" title="选择底层的类"></a>选择底层的类</h5><p>同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。</p>
<h5 id="异步释放对象的技巧"><a href="#异步释放对象的技巧" class="headerlink" title="异步释放对象的技巧"></a>异步释放对象的技巧</h5><p>为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子：</p>
<p>首先将这个缓存的node类取出，然后异步将其释放掉。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        [_lru removeNode:node];</span><br><span class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="comment">//重点部分</span></span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue             &#125;);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">//重点部分</span></span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了class这个消息。</p>
<p>** PS 阅读理解 **</p>
<p>这个线程释放，按我的理解就是，node在执行这个方法后出了作用域，reference 减一，但是block里面调用node，使node 被这个queue Hold 住，reference 加一, 那么，执行完这个block之后，reference count 减一，就达到了再对应线程里面释放目的.如有不对，请指点一下</p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h5><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache官网</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/47704079/answer/135960522">知乎回答 - 信号量与互斥锁区别</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/jenny8080/article/details/52094140">CSDN - 信号量与互斥锁区别</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a657a946fb9a01cb64ee761">YYCache源码解析</a></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>YYCache阅读学习</p><p><a href="https://swlfigo.github.io/posts/5338/">https://swlfigo.github.io/posts/5338/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Sylar</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2019-04-28</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-11-14</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/iOS/">iOS</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5e09772c1fb40b0012b7b886&amp;product=inline-share-buttons&amp;cms=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-12-30-032948.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/5222/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">高性能iOS应用开发</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "qwfDlFFyjoqLxsvp6wMSrQrN-gzGzoHsz",
            appKey: "RTXYfbUeLWuXXJe9cjRX7fJC",
            placeholder: "Type something slowly...",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "en",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-25-032947.jpg" alt="Sylar"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Sylar</p><p class="is-size-6 is-block">一个不会iOS的搬砖工</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/swlfigo" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/sylar.su/"><i class="fab fa-instagram"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://roadmap.isylar.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS-RoadMap</span></span><span class="level-right"><span class="level-item tag">roadmap.isylar.com</span></span></a></li><li><a class="level is-mobile" href="http://tech.isylar.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Tech-Tips</span></span><span class="level-right"><span class="level-item tag">tech.isylar.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Hackintosh/"><span class="level-start"><span class="level-item">Hackintosh</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-13T14:16:59.000Z">2021-11-13</time></p><p class="title"><a href="/posts/941782149/">iOS视频合成预览预处理</a></p><p class="categories"><a href="/categories/iOS/">iOS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-12T15:17:34.000Z">2021-11-12</time></p><p class="title"><a href="/posts/579292555/">Macos Monterey(12) 黑苹果启动变慢解决</a></p><p class="categories"><a href="/categories/Hackintosh/">Hackintosh</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-12T10:09:02.000Z">2021-04-12</time></p><p class="title"><a href="/posts/undefined/">OC下黑苹果以太网已拔出问题</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/2178376574/"><img src="/gallery/gcd-in-swift-thumbnail.jpeg" alt="gcd-in-swift"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-09-21T09:15:48.000Z">2020-09-21</time></p><p class="title"><a href="/posts/2178376574/">gcd-in-swift</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/4106057131/"><img src="https://images.unsplash.com/photo-1581878811201-7d951612a47d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2134&amp;q=80" alt="bitcode"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-16T11:31:55.000Z">2020-02-16</time></p><p class="title"><a href="/posts/4106057131/">bitcode</a></p><p class="categories"><a href="/categories/iOS/">iOS</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hackintosh/"><span class="tag">Hackintosh</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag">20</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Nevermore" height="28"></a><p class="is-size-7"><span>&copy; 2021 Sylar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Follow me on GitHub" href="https://github.com/swlfigo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body></html>